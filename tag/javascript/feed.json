{
    "version": "https://jsonfeed.org/version/1",
    "title": "XGG • All posts by \"javascript\" tag",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2022/06/23/4004_JavaScript%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/",
            "url": "http://example.com/2022/06/23/4004_JavaScript%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/",
            "title": "JavaScript执行上下文",
            "date_published": "2022-06-23T14:12:56.000Z",
            "content_html": "<p>🌸  <span style=\"font-size:bold;color:purple\">Welcome to XGG &amp; blog!</span><br>\n🔭  <span style=\"font-size:bold;color:purple\">When you have eliminated the impossible,whatever remains,however improbable,must be the truth.</span><br>\n📫  <span style=\"font-size:initial;color:purple\">If you get any problems when looking blog,you can find the answer in <a href=\"https://juejin.cn/user/2784392994882045\">稀土掘金</a> or you can ask me on <a href=\"https://github.com/LuckyWishes\">GitHub</a>.</span></p>\n<hr />\n<h4 id=\"1-概念\"><a class=\"markdownIt-Anchor\" href=\"#1-概念\">#</a> 1. 概念</h4>\n<ol>\n<li>在函数执行的时，会创建一个内部对象，即称为执行上下文，同时定义了一个函数执行时的环境</li>\n<li>在一个函数被调用的时，会创建一个活动记录，被称为执行上下文，在这个里面会包含函数调用栈、函数调用方式、传入参数等信息</li>\n<li>每一个函数在被定义的时，会存在一个 <code>[scope]</code>  属性，该属性保存着作用域链</li>\n</ol>\n<h4 id=\"2-类型\"><a class=\"markdownIt-Anchor\" href=\"#2-类型\">#</a> 2. 类型</h4>\n<ol>\n<li>\n<h5 id=\"全局执行上下文\"><a class=\"markdownIt-Anchor\" href=\"#全局执行上下文\">#</a> 全局执行上下文</h5>\n<ol>\n<li>\n<p>只有一个，浏览器的全局对象就是 window 对象，this 指向这个全局对象，在执行全局代码前将 window 确定为全局执行上下文</p>\n</li>\n<li>\n<p>对其全局数据进行处理</p>\n</li>\n<li>\n<p>开始执行全局代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//例子</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a1)<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a2)<br><span class=\"hljs-title function_\">a2</span>()<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>)<br><span class=\"hljs-keyword\">var</span> a1 = <span class=\"hljs-number\">2</span>;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">a2</span>(<span class=\"hljs-params\"></span>)&#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;a2&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li>\n<h5 id=\"函数执行上下文\"><a class=\"markdownIt-Anchor\" href=\"#函数执行上下文\">#</a> 函数执行上下文</h5>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//例子</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">fn</span>(<span class=\"hljs-params\">a1</span>)&#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a1)<br>\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a2)<br>  <span class=\"hljs-title function_\">a3</span>()<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>)<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">arguments</span>)<br>  <span class=\"hljs-keyword\">var</span> a2 = <span class=\"hljs-number\">3</span><br>  <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">a3</span>(<span class=\"hljs-params\"></span>)&#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;a3&quot;</span>)<br>  &#125;<br>&#125;<br><span class=\"hljs-title function_\">fn</span>(<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>)<br></code></pre></td></tr></table></figure>\n<ol>\n<li>只有函数被调用时创建，每次调用都会创建一个新的对应的函数执行上下文对象</li>\n<li>对局部数据进行预处理</li>\n<li>开始执行函数体代码</li>\n</ol>\n</li>\n<li>\n<h5 id=\"eval函数执行上下文\"><a class=\"markdownIt-Anchor\" href=\"#eval函数执行上下文\">#</a>  <code>Eval函数</code> 执行上下文</h5>\n<ol>\n<li>运行在该函数中的代码</li>\n</ol>\n</li>\n</ol>\n<p>概念：EC : 执行上下文、ECS : 执行上下文栈、VO ： 变量对象、AO ： 活动对象、scope chain : 作用域链</p>\n<p><code>VO变量对象</code> ：创建执行上下文时与之关联的会有一个变量对象，该上下文中的所有变量和函数全都保存在这个对象中</p>\n<p><code>AO活动对象</code> ：进入到一个执行上下文时，此执行上下文中的变量和函数都可以被访问到，可以理解为被激活</p>\n<h3 id=\"2-执行上下文的具体过程\"><a class=\"markdownIt-Anchor\" href=\"#2-执行上下文的具体过程\">#</a> 2. 执行上下文的具体过程</h3>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\">i</span>) &#123;  <br>  <span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-string\">&#x27;hello&#x27;</span>;  <br>  <span class=\"hljs-keyword\">var</span> b = <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">privateB</span>(<span class=\"hljs-params\"></span>) &#123;&#125;;  <br>  <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">c</span>(<span class=\"hljs-params\"></span>) &#123;&#125;  <br>&#125;  <br><span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-number\">22</span>);<br></code></pre></td></tr></table></figure>\n<h4 id=\"1-创建阶段函数被调用但是还未执行函数中的代码\"><a class=\"markdownIt-Anchor\" href=\"#1-创建阶段函数被调用但是还未执行函数中的代码\">#</a> 1. 创建阶段（函数被调用，但是还未执行函数中的代码）</h4>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//创建时函数体中相关代码（代码1）</span><br>fooExecutionContext = &#123;  <br>  <span class=\"hljs-attr\">variableObject</span>: &#123;  <br>  <span class=\"hljs-attr\">arguments</span>: &#123;  <br>      <span class=\"hljs-number\">0</span>: <span class=\"hljs-number\">22</span>,  <br>      <span class=\"hljs-attr\">length</span>: <span class=\"hljs-number\">1</span>  <br>    &#125;,  <br>    <span class=\"hljs-attr\">i</span>: <span class=\"hljs-number\">22</span>,  <br>    <span class=\"hljs-attr\">c</span>: pointer to <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">c</span>(<span class=\"hljs-params\"></span>),  <br>  <span class=\"hljs-attr\">a</span>: <span class=\"hljs-literal\">undefined</span>,  <br>  <span class=\"hljs-attr\">b</span>: <span class=\"hljs-literal\">undefined</span>  <br>\t&#125;,  <br>  <span class=\"hljs-attr\">scopeChain</span>: &#123; ... &#125;,  <br>    <span class=\"hljs-attr\">this</span>: &#123; ... &#125;  <br>&#125; <br></code></pre></td></tr></table></figure>\n<ol>\n<li>创建变量对象 (VO)\n<ol>\n<li>创建 arguments，检查当前上下文的参数，建立该对象下的属性和属性值</li>\n<li>扫描上下文的函数申明\n<ol>\n<li>每扫描到一个函数，就会在 VO 里面用函数名创建一个属性，为一个指针，指向该函数在内存中的地址</li>\n<li>如果函数名在 VO 中已经存在，对应的属性值会被新的引用覆盖</li>\n<li>即为 var（undefined）定义的全局变量为 window 属性、function（fun）声明全局函数为 window 方法、this 赋值为 widow</li>\n</ol>\n</li>\n<li>扫描上下文的变量申明：\n<ol>\n<li>每扫描到一个变量就会用变量名作为属性名，其值初始化为 undefined</li>\n<li>如果该变量名在 VO 中已经存在，则直接跳过继续扫描</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>初始化作用域链</li>\n<li>确定上下文中 this 的指向</li>\n</ol>\n<h4 id=\"2-代码执行阶段\"><a class=\"markdownIt-Anchor\" href=\"#2-代码执行阶段\">#</a> 2. 代码执行阶段</h4>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//执行时函数体中相关代码（代码2）</span><br>fooExecutionContext = &#123;  <br>  <span class=\"hljs-attr\">variableObject</span>: &#123;  <br>    <span class=\"hljs-attr\">arguments</span>: &#123;  <br>      <span class=\"hljs-number\">0</span>: <span class=\"hljs-number\">22</span>,  <br>      <span class=\"hljs-attr\">length</span>: <span class=\"hljs-number\">1</span>  <br>    &#125;,  <br>    <span class=\"hljs-attr\">i</span>: <span class=\"hljs-number\">22</span>,  <br>    <span class=\"hljs-attr\">c</span>: pointer to <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">c</span>(<span class=\"hljs-params\"></span>),  <br>  <span class=\"hljs-attr\">a</span>: <span class=\"hljs-string\">&#x27;hello&#x27;</span>,  <br>  <span class=\"hljs-attr\">b</span>: pointer to <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">privateB</span>(<span class=\"hljs-params\"></span>)  <br>\t&#125;,  <br>  <span class=\"hljs-attr\">scopeChain</span>: &#123; ... &#125;,  <br>    <span class=\"hljs-attr\">this</span>: &#123; ... &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>执行函数体中的代码，给 VO 中的变量赋值</li>\n</ol>\n<h3 id=\"3-执行上下文栈execution-context-stack\"><a class=\"markdownIt-Anchor\" href=\"#3-执行上下文栈execution-context-stack\">#</a> 3. 执行上下文栈 <code>Execution context stack</code></h3>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//知识小练</span><br><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">10</span><br><span class=\"hljs-keyword\">var</span> bar = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">x</span>)&#123;<br>  <span class=\"hljs-keyword\">var</span> b = <span class=\"hljs-number\">5</span><br>  <span class=\"hljs-title function_\">foo</span>(x + b)<br>&#125;<br><span class=\"hljs-keyword\">var</span> foo = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">y</span>)&#123;<br>  <span class=\"hljs-keyword\">var</span> c = <span class=\"hljs-number\">5</span><br>  <span class=\"hljs-title function_\">foo1</span>(a + c + y)<br>&#125;<br><span class=\"hljs-title function_\">bar</span>(<span class=\"hljs-number\">10</span>) <br><br></code></pre></td></tr></table></figure>\n<h4 id=\"1-执行栈调用栈\"><a class=\"markdownIt-Anchor\" href=\"#1-执行栈调用栈\">#</a> 1. 执行栈（调用栈）</h4>\n<ol>\n<li>具有 LIFO 结构（后进先出），用于存储在代码执行期间创建的上下文（函数的执行顺序和定义顺序没有关系，可以通过执行栈理解）</li>\n<li></li>\n</ol>\n<h4 id=\"2-原理\"><a class=\"markdownIt-Anchor\" href=\"#2-原理\">#</a> 2. 原理</h4>\n<ol>\n<li>每当执行 js 代码时，创建一个全局执行上下文并且 push 当前的执行上下文栈顶，此后每发生一次函数调用，搜索引擎会创建一个新的函数执行上下文，并且将其 push 当前执行栈的栈顶，当栈顶的函数执行完毕，执行栈中对应的执行上下文就会 pop，同时变量对象 <code>VO</code>  也会销毁，栈指针将会指向下一个执行上下文，直至应用关闭时将会销毁全局上下文</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/2020061514072717.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2piajY1Njg4Mzl6,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//课前小练</span><br><span class=\"hljs-comment\">//问题一</span><br><span class=\"hljs-keyword\">var</span> scope = <span class=\"hljs-string\">&quot;global scope&quot;</span>;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">checkscope</span>(<span class=\"hljs-params\"></span>)&#123;<br>    <span class=\"hljs-keyword\">var</span> scope = <span class=\"hljs-string\">&quot;local scope&quot;</span>;<br>    <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\"></span>)&#123;<br>        <span class=\"hljs-keyword\">return</span> scope;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">f</span>();<br>&#125;<br><span class=\"hljs-title function_\">checkscope</span>();<br><br><span class=\"hljs-comment\">//问题二</span><br><span class=\"hljs-keyword\">var</span> scope = <span class=\"hljs-string\">&quot;global scope&quot;</span>;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">checkscope</span>(<span class=\"hljs-params\"></span>)&#123;<br>    <span class=\"hljs-keyword\">var</span> scope = <span class=\"hljs-string\">&quot;local scope&quot;</span>;<br>    <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\"></span>)&#123;<br>        <span class=\"hljs-keyword\">return</span> scope;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> f;<br>&#125;<br><span class=\"hljs-title function_\">checkscope</span>()();<br><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//经典面试题1</span><br>问题<span class=\"hljs-number\">1</span>：依次输出？<br>问题<span class=\"hljs-number\">2</span>：一共产生多少执行山下文对象？<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;gb:&#x27;</span>+i)<br><span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">1</span><br><span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-number\">1</span>)<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\">i</span>)&#123;<br>  <span class=\"hljs-keyword\">if</span>(i == <span class=\"hljs-number\">4</span>)&#123;<br>    <span class=\"hljs-keyword\">return</span><br>  &#125;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;fb:&#x27;</span>+i)<br>  <span class=\"hljs-title function_\">foo</span>(i + <span class=\"hljs-number\">1</span>)<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;fe:&#x27;</span>+i)<br>&#125;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;ge:&#x27;</span>+i)<br><br>输出：<br><span class=\"hljs-literal\">undefined</span><br><span class=\"hljs-number\">1</span><br><span class=\"hljs-number\">2</span><br><span class=\"hljs-number\">3</span><br><span class=\"hljs-number\">3</span><br><span class=\"hljs-number\">2</span><br><span class=\"hljs-number\">1</span><br><span class=\"hljs-number\">1</span><br></code></pre></td></tr></table></figure>\n",
            "tags": [
                "JavaScript"
            ]
        },
        {
            "id": "http://example.com/2022/06/19/4003_JavaScript%E5%8E%9F%E5%9E%8B%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/",
            "url": "http://example.com/2022/06/19/4003_JavaScript%E5%8E%9F%E5%9E%8B%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/",
            "title": "原型 原型链 继承",
            "date_published": "2022-06-19T14:12:03.000Z",
            "content_html": "<p>🌸  <span style=\"font-size:bold;color:purple\">Welcome to XGG &amp; blog!</span><br>\n🔭  <span style=\"font-size:bold;color:purple\">When you have eliminated the impossible,whatever remains,however improbable,must be the truth.</span><br>\n📫  <span style=\"font-size:initial;color:purple\">If you get any problems when looking blog,you can find the answer in <a href=\"https://juejin.cn/user/2784392994882045\">稀土掘金</a> or you can ask me on <a href=\"https://github.com/LuckyWishes\">GitHub</a>.</span></p>\n<hr />\n<h3 id=\"prototype\"><a class=\"markdownIt-Anchor\" href=\"#prototype\">#</a> prototype</h3>\n<blockquote>\n<p><strong>原型的概念</strong></p>\n<p>每一个 JavaScript 对象 (除了 <code>null</code>  外) 创建的时候，就会与之关联另一个对象，这个<strong>对象</strong>就是我们所说的<strong>原型</strong>，每一个对象都会从原型中 &quot;继承&quot; 属性。</p>\n</blockquote>\n<p>在 JavaScript 中，<strong>每个函数</strong>都有一个 <code>prototype</code>  属性，该属性指向函数的原型对象。</p>\n<h3 id=\"__-proto-__\"><a class=\"markdownIt-Anchor\" href=\"#__-proto-__\">#</a> __ proto __</h3>\n<p><strong>每个对象</strong> (除了 <code>null</code>  外) 都会有的属性，叫做 <code>__proto__</code> ，这个属性会指向该对象的原型。</p>\n<blockquote>\n<p>绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于  <code>Person.prototype</code>  中，实际上，它是来自于  <code>Object.prototype</code>  ，与其说是一个属性，不如说是一个  <code>getter/setter</code> ，当使用  <code>obj.__proto__</code>  时，可以理解成返回了  <code>Object.getPrototypeOf(obj)</code></p>\n</blockquote>\n<h3 id=\"constructor\"><a class=\"markdownIt-Anchor\" href=\"#constructor\">#</a> constructor</h3>\n<p>每个原型都有一个 <code>constructor</code> ，指向该关联的构造函数</p>\n<blockquote>\n<p>当获取 person.constructor 时，其实 person 中并没有 constructor 属性，当不能读取到 constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取</p>\n</blockquote>\n<h3 id=\"实例与原型\"><a class=\"markdownIt-Anchor\" href=\"#实例与原型\">#</a> 实例与原型</h3>\n<p>当读取实例的属性时，如果找不到，就通过隐式原型 ( <code>__proto__</code> ) 向上查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层，若最顶层也找不到，则返回 undefined。</p>\n<h3 id=\"原型的原型\"><a class=\"markdownIt-Anchor\" href=\"#原型的原型\">#</a> 原型的原型</h3>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它</span><br><span class=\"hljs-keyword\">var</span> obj = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Object</span>();<br>obj.<span class=\"hljs-property\">name</span> = <span class=\"hljs-string\">&#x27;Kevin&#x27;</span>;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj.<span class=\"hljs-property\">name</span>);<br></code></pre></td></tr></table></figure>\n<p>原型对象就是通过 Object 构造函数生成的。又因为实例的 <code>__proto__</code> 指向构造函数的 <code>prototype</code>  所以得到总的关系图：</p>\n<p><img src=\"%E5%8E%9F%E5%9E%8B%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE%E3%80%81%E7%BB%A7%E6%89%BF.assets/850375-20190708152327825-11086376.png\" alt=\"img\"></p>\n<h3 id=\"原型链\"><a class=\"markdownIt-Anchor\" href=\"#原型链\">#</a> 原型链</h3>\n<blockquote>\n<p>每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。那么假如我们让原型对象等于另一个类型的实例，结果会怎样？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立。如此层层递进，就构成了实例与原型的链条。这就是所谓的原型链的基本概念。</p>\n<p>​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t—— 摘自《javascript 高级程序设计》</p>\n</blockquote>\n<p>最后，由于 Object 的原型对象是 null，所以得出最终的图</p>\n<p><img src=\"%E5%8E%9F%E5%9E%8B%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE%E3%80%81%E7%BB%A7%E6%89%BF.assets/850375-20190708153139577-2105652554.png\" alt=\"img\"></p>\n<p><img src=\"%E5%8E%9F%E5%9E%8B%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE%E3%80%81%E7%BB%A7%E6%89%BF.assets/1691fc878b9beefa~tplv-t2oaga2asx-watermark.awebp\" alt=\"img\"></p>\n<h3 id=\"继承\"><a class=\"markdownIt-Anchor\" href=\"#继承\">#</a> 继承</h3>\n<h5 id=\"原型链继承\"><a class=\"markdownIt-Anchor\" href=\"#原型链继承\">#</a> 原型链继承</h5>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">SuperType</span>(<span class=\"hljs-params\"></span>) &#123;<span class=\"hljs-number\">0</span><br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> = <span class=\"hljs-literal\">true</span>;<br>&#125;<br><span class=\"hljs-title class_\">SuperType</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">getSuperValue</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span><br>&#125;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">SubType</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">subProperty</span> = <span class=\"hljs-literal\">false</span><br>&#125;<br><span class=\"hljs-title class_\">SubType</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">getSubValue</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">subProperty</span><br>&#125;<br><span class=\"hljs-comment\">// 关键，创建SuperType的实例，让SubType.prototype指向这个实例</span><br><span class=\"hljs-title class_\">SubType</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SuperType</span>()<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">dir</span>(<span class=\"hljs-title class_\">SuperType</span>)<br><span class=\"hljs-keyword\">let</span> inst1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SuperType</span>()<br><span class=\"hljs-keyword\">let</span> inst2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SubType</span>()<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(inst2.<span class=\"hljs-title function_\">getSuperValue</span>()) <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<h6 id=\"优点\"><a class=\"markdownIt-Anchor\" href=\"#优点\">#</a> 优点：</h6>\n<ul>\n<li>父类方法可以复用</li>\n</ul>\n<h6 id=\"缺点\"><a class=\"markdownIt-Anchor\" href=\"#缺点\">#</a> 缺点：</h6>\n<ul>\n<li>父类的引用属性会被所有子类实例共享，多个实例对引用类型的操作会被篡改</li>\n<li>子类构建实例时不能向父类传递参数</li>\n</ul>\n<h5 id=\"构造函数继承\"><a class=\"markdownIt-Anchor\" href=\"#构造函数继承\">#</a> 构造函数继承</h5>\n<p>使用父类构造函数来增强子类<strong>实例</strong>，等同于复制父类的实例给子类 (不使用原型)</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">SuperType</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">color</span> = [<span class=\"hljs-string\">&#x27;red&#x27;</span>, <span class=\"hljs-string\">&#x27;green&#x27;</span>]<br>&#125;<br><br><span class=\"hljs-comment\">// 构造函数继承</span><br><span class=\"hljs-comment\">// 使得每个实例都会复制得到自己独有的一份属性</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">SubType</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-comment\">// 将父对象的构造函数绑定在子对象上</span><br>  <span class=\"hljs-title class_\">SuperType</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-variable language_\">this</span>)<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> inst1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SubType</span>()<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(inst1)<br><br><span class=\"hljs-comment\">// SubType &#123;color: Array(2)&#125;</span><br></code></pre></td></tr></table></figure>\n<p>创建子类实例时调用 <code>SuperType</code>  构造函数，于是 <code>SubType</code>  的每个实例都会将 SuperType 中的属性复制一份，<strong>解决了原型链继承中多实例相互影响的问题</strong>。</p>\n<h6 id=\"优点-2\"><a class=\"markdownIt-Anchor\" href=\"#优点-2\">#</a> 优点：</h6>\n<ul>\n<li>父类的引用属性不会被共享</li>\n<li>子类构建实例时可以向父类传递参数</li>\n</ul>\n<h6 id=\"缺点-2\"><a class=\"markdownIt-Anchor\" href=\"#缺点-2\">#</a> 缺点：</h6>\n<ul>\n<li>只能继承父类的<strong>实例</strong>属性和方法，不能继承原型属性 / 方法</li>\n<li>无法实现复用，每个子类都有父类实例函数的副本，影响性能</li>\n</ul>\n<h5 id=\"组合继承上面两种结合起来\"><a class=\"markdownIt-Anchor\" href=\"#组合继承上面两种结合起来\">#</a> 组合继承（上面两种结合起来）</h5>\n<p>组合上述两种方法，用原型链实现对<strong>原型</strong>属性的继承，用构造函数来实现<strong>实例</strong>属性的继承</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">SuperType</span>(<span class=\"hljs-params\">name</span>) &#123;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = name<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">colors</span> = [<span class=\"hljs-string\">&#x27;red&#x27;</span>, <span class=\"hljs-string\">&#x27;blue&#x27;</span>, <span class=\"hljs-string\">&#x27;green&#x27;</span>]<br>&#125;<br><br><span class=\"hljs-title class_\">SuperType</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">getName</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span><br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">SubType</span>(<span class=\"hljs-params\">name, age</span>) &#123;<br>  <span class=\"hljs-comment\">// 1、构造函数来复制父类的属性给SubType实例</span><br>  <span class=\"hljs-comment\">// *** 第二次调用SuperType()</span><br>  <span class=\"hljs-title class_\">SuperType</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-variable language_\">this</span>, name)<br>  <span class=\"hljs-comment\">// call() 允许为不同的对象分配和调用属于一个对象的函数/方法。</span><br>  <span class=\"hljs-comment\">// call() 提供新的 this 值给当前调用的函数/方法。你可以使用 call 来实现继承：写一个方法，然后让另外一个新的对象来继承它（而不是在新对象中再写一次这个方法）。</span><br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">age</span> = age<br>&#125;<br><br><span class=\"hljs-title class_\">SubType</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">getAge</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">age</span><br>&#125;<br><br><span class=\"hljs-comment\">// 2、原型继承</span><br><span class=\"hljs-comment\">// *** 第一次调用SuperType()</span><br><span class=\"hljs-title class_\">SubType</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SuperType</span>()<br><span class=\"hljs-comment\">// 手动挂上构造器，指向自己的构造函数 SubType</span><br><span class=\"hljs-title class_\">SubType</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">constructor</span> = <span class=\"hljs-title class_\">SubType</span><br><span class=\"hljs-title class_\">SubType</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">getAge</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">age</span><br>&#125;<br><br><span class=\"hljs-keyword\">let</span> inst1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SubType</span>(<span class=\"hljs-string\">&#x27;Asuna&#x27;</span>, <span class=\"hljs-number\">20</span>)<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;inst1&#x27;</span>, inst1)<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(inst1.<span class=\"hljs-title function_\">getName</span>(), inst1.<span class=\"hljs-title function_\">getAge</span>())<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(inst1 <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">SubType</span>, inst1 <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">SuperType</span>)<br><br><br><span class=\"hljs-comment\">// inst1 SubType &#123;name: &quot;Asuna&quot;, colors: Array(3), age: 20&#125;</span><br><span class=\"hljs-comment\">// Asuna 20</span><br><span class=\"hljs-comment\">// true true</span><br></code></pre></td></tr></table></figure>\n<h6 id=\"优点-3\"><a class=\"markdownIt-Anchor\" href=\"#优点-3\">#</a> 优点：</h6>\n<ul>\n<li>父类的方法可以被复用</li>\n<li>父类的引用属性不会被共享</li>\n<li>子类构建实例时可以向父类传递参数</li>\n</ul>\n<h6 id=\"缺点对照注释\"><a class=\"markdownIt-Anchor\" href=\"#缺点对照注释\">#</a> 缺点（对照注释）：</h6>\n<ul>\n<li>第一次调用 <code>SuperType()</code> ：给 <code>SubType.prototype</code>  写入两个属性 name，color。</li>\n<li>第二次调用 <code>SuperType()</code> ：给 <code>instance1</code>  写入两个属性 name，color。</li>\n</ul>\n<p>实例对象 <code>inst1</code>  上的两个属性就屏蔽了其原型对象 SubType.prototype 的两个同名属性。所以，组合模式的缺点就是在使用子类创建实例对象时，其原型中会存在两份相同的父类实例的属性 / 方法。这种被覆盖的情况造成了性能上的浪费。</p>\n<h5 id=\"原型式继承浅拷贝\"><a class=\"markdownIt-Anchor\" href=\"#原型式继承浅拷贝\">#</a> 原型式继承 (浅拷贝)</h5>\n<p><code>Object.create()</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> person = &#123;<br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Nicholas&quot;</span>,<br>  <span class=\"hljs-attr\">friends</span>: [<span class=\"hljs-string\">&quot;Shelby&quot;</span>, <span class=\"hljs-string\">&quot;Court&quot;</span>, <span class=\"hljs-string\">&quot;Van&quot;</span>]<br>&#125;;<br><br><span class=\"hljs-keyword\">let</span> anotherPerson = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">create</span>(person);<br>anotherPerson.<span class=\"hljs-property\">name</span> = <span class=\"hljs-string\">&quot;Greg&quot;</span>;<br>anotherPerson.<span class=\"hljs-property\">friends</span>.<span class=\"hljs-title function_\">push</span>(<span class=\"hljs-string\">&quot;Rob&quot;</span>);<br><br><span class=\"hljs-keyword\">let</span> yetAnotherPerson = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">create</span>(person);<br>yetAnotherPerson.<span class=\"hljs-property\">name</span> = <span class=\"hljs-string\">&quot;Linda&quot;</span>;<br>yetAnotherPerson.<span class=\"hljs-property\">friends</span>.<span class=\"hljs-title function_\">push</span>(<span class=\"hljs-string\">&quot;Barbie&quot;</span>);<br><br><span class=\"hljs-title function_\">alert</span>(person.<span class=\"hljs-property\">friends</span>);   <span class=\"hljs-comment\">//&quot;Shelby,Court,Van,Rob,Barbie&quot;</span><br></code></pre></td></tr></table></figure>\n<h6 id=\"优点-4\"><a class=\"markdownIt-Anchor\" href=\"#优点-4\">#</a> 优点：</h6>\n<ul>\n<li>父类方法可以复用</li>\n</ul>\n<h6 id=\"缺点-3\"><a class=\"markdownIt-Anchor\" href=\"#缺点-3\">#</a> 缺点：</h6>\n<ul>\n<li>原型链继承多个实例的引用类型属性指向相同，存在篡改的可能</li>\n<li>子类构建实例时不能向父类传递参数</li>\n</ul>\n<h5 id=\"寄生式继承能附加一些方法\"><a class=\"markdownIt-Anchor\" href=\"#寄生式继承能附加一些方法\">#</a> 寄生式继承（能附加一些方法）</h5>\n<p>使用原型式继承获得一份目标对象的<strong>浅拷贝</strong>，然后增强了这个浅拷贝的能力。</p>\n<p><strong>优缺点其实和原型式继承一样</strong>，寄生式继承说白了就是能在拷贝来的对象上加点方法，也就是所谓增强能力。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">object</span>(<span class=\"hljs-params\">obj</span>) &#123;<br>  <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">F</span>(<span class=\"hljs-params\"></span>) &#123; &#125;<br>  F.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> = obj<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">F</span>()<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createAnother</span>(<span class=\"hljs-params\">original</span>) &#123;<br>  <span class=\"hljs-comment\">// 通过调用函数创建一个新对象</span><br>  <span class=\"hljs-keyword\">let</span> clone = <span class=\"hljs-title function_\">object</span>(original)<br>  <span class=\"hljs-comment\">//以某种方式来增强这个对象</span><br>  clone.<span class=\"hljs-property\">getName</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;我有了getName方法: &#x27;</span> + <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span>)<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> clone<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> person = &#123;<br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;Asuna&#x27;</span>,<br>  <span class=\"hljs-attr\">friends</span>: [<span class=\"hljs-string\">&#x27;Kirito&#x27;</span>, <span class=\"hljs-string\">&#x27;Yuuki&#x27;</span>, <span class=\"hljs-string\">&#x27;Sinon&#x27;</span>]<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> inst1 = <span class=\"hljs-title function_\">createAnother</span>(person)<br><span class=\"hljs-keyword\">let</span> inst2 = <span class=\"hljs-title function_\">createAnother</span>(person)<br></code></pre></td></tr></table></figure>\n<h6 id=\"优点-5\"><a class=\"markdownIt-Anchor\" href=\"#优点-5\">#</a> 优点：</h6>\n<ul>\n<li>父类方法可以复用</li>\n</ul>\n<h6 id=\"缺点-4\"><a class=\"markdownIt-Anchor\" href=\"#缺点-4\">#</a> 缺点：</h6>\n<ul>\n<li>原型链继承多个实例的引用类型属性指向相同，存在篡改的可能</li>\n<li>子类构建实例时不能向父类传递参数</li>\n</ul>\n<h5 id=\"寄生组合继承最优方案\"><a class=\"markdownIt-Anchor\" href=\"#寄生组合继承最优方案\">#</a> 寄生组合继承（最优方案）</h5>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">inheritPrototype</span>(<span class=\"hljs-params\">subType, superType</span>) &#123;<br>  <span class=\"hljs-comment\">// 修正子类原型对象指针，指向父类原型的一个副本 (用object()也可以) </span><br>  subType.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">create</span>(superType.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>)<br>  <span class=\"hljs-comment\">// 增强对象，弥补因重写原型而失去的默认的constructor属性</span><br>  subType.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">constructor</span> = subType<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">SuperType</span>(<span class=\"hljs-params\">name</span>) &#123;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = name<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">colors</span> = [<span class=\"hljs-string\">&#x27;red&#x27;</span>, <span class=\"hljs-string\">&#x27;blue&#x27;</span>, <span class=\"hljs-string\">&#x27;green&#x27;</span>]<br>&#125;<br><br><span class=\"hljs-title class_\">SuperType</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">getColors</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">colors</span>)<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">SubType</span>(<span class=\"hljs-params\">name, age</span>) &#123;<br>  <span class=\"hljs-title class_\">SuperType</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-variable language_\">this</span>, name)<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">age</span> = age<br>&#125;<br><br><span class=\"hljs-title function_\">inheritPrototype</span>(<span class=\"hljs-title class_\">SubType</span>, <span class=\"hljs-title class_\">SuperType</span>)<br><br><span class=\"hljs-title class_\">SubType</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">getAge</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">age</span>)<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> inst1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SubType</span>(<span class=\"hljs-string\">&quot;Asuna&quot;</span>, <span class=\"hljs-number\">20</span>)<br><span class=\"hljs-keyword\">let</span> inst2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SubType</span>(<span class=\"hljs-string\">&quot;Krito&quot;</span>, <span class=\"hljs-number\">21</span>)<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;inst1&#x27;</span>, inst1)<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;inst2&#x27;</span>, inst2)<br></code></pre></td></tr></table></figure>\n<h5 id=\"多继承\"><a class=\"markdownIt-Anchor\" href=\"#多继承\">#</a> 多继承</h5>\n<p>如果你希望能继承到多个对象，则可以使用混入的方式。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">MyClass</span>(<span class=\"hljs-params\"></span>) &#123;<br>     <span class=\"hljs-title class_\">SuperClass</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-variable language_\">this</span>);<br>     <span class=\"hljs-title class_\">OtherSuperClass</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-variable language_\">this</span>);<br>&#125;<br><br><span class=\"hljs-comment\">// 继承一个类（就是寄生组合继承的套路）</span><br><span class=\"hljs-title class_\">MyClass</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">create</span>(<span class=\"hljs-title class_\">SuperClass</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>);<br><br><span class=\"hljs-comment\">// 混合其它类，关键是这里的 assign() 方法</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(<span class=\"hljs-title class_\">MyClass</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>, <span class=\"hljs-title class_\">OtherSuperClass</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>);<br><br><span class=\"hljs-comment\">// 重新指定constructor</span><br><span class=\"hljs-title class_\">MyClass</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">constructor</span> = <span class=\"hljs-title class_\">MyClass</span>;<br><br><span class=\"hljs-comment\">// 在之类上附加方法</span><br><span class=\"hljs-title class_\">MyClass</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">myMethod</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-comment\">// do a thing</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>Object.assign 会把  <code>OtherSuperClass</code>  原型上的函数拷贝到  <code>MyClass</code>  原型上，使 MyClass 的所有实例都可用 OtherSuperClass 的方法。Object.assign 是在 ES2015 引入的，且可用 polyfilled。要支持旧浏览器的话，可用使用 jQuery.extend () 或者_.assign ()。 ——[MDN] Object.create ()</p>\n</blockquote>\n<h5 id=\"es6-extends\"><a class=\"markdownIt-Anchor\" href=\"#es6-extends\">#</a> ES6 extends</h5>\n<blockquote>\n<p>虽然 ES6 引入了关键字 class，但是底层仍然是基于原型的实现。class 只是语法糖，使得在 JavaScript 模拟类的代码更为简洁。</p>\n<p>​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t——《JavaScript 忍者秘籍》</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Person</span> &#123;<br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">name</span>) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = name<br>  &#125;<br><br>  <span class=\"hljs-comment\">// 原型方法</span><br>  <span class=\"hljs-comment\">// 即 Person.prototype.getName = function() &#123; &#125;</span><br>  <span class=\"hljs-comment\">// 下面可以简写为 getName() &#123;...&#125;</span><br>  getName = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Person:&#x27;</span>, <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span>)<br>  &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Gamer</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Person</span> &#123;<br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">name, age</span>) &#123;<br>    <span class=\"hljs-comment\">// 子类中存在构造函数，则需要在使用“this”之前首先调用 super()。</span><br>    <span class=\"hljs-variable language_\">super</span>(name)<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">age</span> = age<br>  &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> asuna = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Gamer</span>(<span class=\"hljs-string\">&#x27;Asuna&#x27;</span>, <span class=\"hljs-number\">20</span>)<br>asuna.<span class=\"hljs-title function_\">getName</span>() <span class=\"hljs-comment\">// 成功访问到父类的方法</span><br></code></pre></td></tr></table></figure>\n<p><strong> <code>super</code>  实现的原理</strong></p>\n<p>就是将继承的那个父类对象在子类中调用，比如  <code>super.call(this)</code>  实现将父类中的属性 (父类的方法是通过原型链来继承，实例都可以共享这些方法) 在子类中声明。</p>\n<h3 id=\"作用域和作用域链\"><a class=\"markdownIt-Anchor\" href=\"#作用域和作用域链\">#</a> 作用域和作用域链</h3>\n<h3 id=\"作用域的概念\"><a class=\"markdownIt-Anchor\" href=\"#作用域的概念\">#</a> 作用域的概念</h3>\n<p>字面意思就是起作用的范围。</p>\n<h3 id=\"全局作用域\"><a class=\"markdownIt-Anchor\" href=\"#全局作用域\">#</a> 全局作用域</h3>\n<p>在代码中任何地方都能访问到的对象拥有全局作用域</p>\n<p>常见情况</p>\n<ul>\n<li>最外层函数 和在最外层函数外面定义的变量拥有全局作用域</li>\n<li>所有末定义直接赋值的变量自动声明为拥有全局作用域</li>\n<li>所有 window 对象的属性拥有全局作用域\n<ul>\n<li>此处的 window 对象意味顶层对象，不同环境下有可能顶层对象不同</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"局部作用域\"><a class=\"markdownIt-Anchor\" href=\"#局部作用域\">#</a> 局部作用域</h3>\n<p>块级作用域可通过新增命令 let 和 const 声明，所声明的变量在指定块的作用域外无法被访问。块级作用域在如下情况被创建：</p>\n<ol>\n<li>在一个函数内部</li>\n<li>在一个代码块（由一对花括号包裹）内部</li>\n</ol>\n<h5 id=\"暂时性死区\"><a class=\"markdownIt-Anchor\" href=\"#暂时性死区\">#</a> 暂时性死区</h5>\n<ul>\n<li><strong>var 的创建和初始化被提升，赋值不会被提升。</strong></li>\n<li><strong>let 的创建被提升，初始化和赋值不会被提升。</strong></li>\n<li><strong>function 的创建、初始化和赋值均会被提升。</strong></li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">test</span>(<span class=\"hljs-params\"></span>)&#123;<br>\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a)<br>\t<span class=\"hljs-keyword\">let</span> a = <span class=\"hljs-number\">7</span>;<br>&#125;<br><span class=\"hljs-title function_\">test</span>()<br></code></pre></td></tr></table></figure>\n<h5 id=\"函数作用域\"><a class=\"markdownIt-Anchor\" href=\"#函数作用域\">#</a> 函数作用域</h5>\n<p>指在函数内部生效。</p>\n<h5 id=\"作用域链\"><a class=\"markdownIt-Anchor\" href=\"#作用域链\">#</a> 作用域链</h5>\n<p>当前作用域内找不到的变量会根据作用域链向上寻找，直到顶层对象 window 也没有就返回 undefined。</p>\n<h3 id=\"作用域与执行上下文\"><a class=\"markdownIt-Anchor\" href=\"#作用域与执行上下文\">#</a> 作用域与执行上下文</h3>\n<p>JavaScript 属于解释型语言，JavaScript 的执行分为：解释和执行两个阶段，这两个阶段所做的事并不一样：</p>\n<h5 id=\"解释阶段\"><a class=\"markdownIt-Anchor\" href=\"#解释阶段\">#</a> 解释阶段：</h5>\n<ul>\n<li>词法分析</li>\n<li>语法分析</li>\n<li>作用域规则确定</li>\n</ul>\n<h5 id=\"执行阶段\"><a class=\"markdownIt-Anchor\" href=\"#执行阶段\">#</a> 执行阶段：</h5>\n<ul>\n<li>创建执行上下文</li>\n<li>执行函数代码</li>\n<li>垃圾回收</li>\n</ul>\n<p>JavaScript 解释阶段便会确定作用域规则，因此作用域在函数定义时就已经确定了，而不是在函数调用时确定，但是执行上下文是函数执行之前创建的。执行上下文最明显的就是 this 的指向是执行时确定的。而作用域访问的变量是编写代码的结构确定的。</p>\n<p>一个作用域下可能包含若干个上下文环境。有可能从来没有过上下文环境（函数从来就没有被调用过）；有可能有过，现在函数被调用完毕后，上下文环境被销毁了；有可能同时存在一个或多个（闭包）。<strong>同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值</strong></p>\n",
            "tags": [
                "JavaScript"
            ]
        },
        {
            "id": "http://example.com/2022/06/17/4002_JavaScript%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E4%B8%8E%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87/",
            "url": "http://example.com/2022/06/17/4002_JavaScript%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E4%B8%8E%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87/",
            "title": "变量提升与函数提升",
            "date_published": "2022-06-17T07:43:53.000Z",
            "content_html": "<p>🌸  <span style=\"font-size:bold;color:purple\">Welcome to XGG &amp; blog!</span><br>\n🔭  <span style=\"font-size:bold;color:purple\">When you have eliminated the impossible,whatever remains,however improbable,must be the truth.</span><br>\n📫  <span style=\"font-size:initial;color:purple\">If you get any problems when looking blog,you can find the answer in <a href=\"https://juejin.cn/user/2784392994882045\">稀土掘金</a> or you can ask me on <a href=\"https://github.com/LuckyWishes\">GitHub</a>.</span></p>\n<hr />\n<h3 id=\"1-提升\"><a class=\"markdownIt-Anchor\" href=\"#1-提升\">#</a> 1 提升</h3>\n<p>在 j s 代码执行前引擎会先进行预编译，预编 译期间会将变量声明与函数声明提升至其对应作用域的最顶端。</p>\n<h3 id=\"2-变量提升\"><a class=\"markdownIt-Anchor\" href=\"#2-变量提升\">#</a> 2 变量提升</h3>\n<p>在 ES 6 出来之前，J S 并没有块级作用域这一说，只有全局作用域和局部作用域。变量提升指的是<strong>使用 var 声明的变量提升到他所在的作用域的最顶端</strong>。创建阶段，初始化阶段变量提升，赋值阶段没有提升，值为 undefined。</p>\n<pre><code class=\"hljs\">* 赋值逻辑不提升\n* 全局变量会被局部作用域中的同名变量覆盖\n</code></pre>\n<p>let，con st 变量，在创建阶段被提升了，但初始化和赋值阶段都没有被提升，没法使用变量，都存在一个暂时性死区。</p>\n<h3 id=\"3-函数提升\"><a class=\"markdownIt-Anchor\" href=\"#3-函数提升\">#</a> 3 函数提升</h3>\n<p>函数声明提升：是将函数名及函数体全部提升到其所在作用域的顶部。</p>\n<p>函数创建有两个方式：</p>\n<p>1，函数声明形式</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 声明式</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span> () &#123;<br>    <span class=\"hljs-comment\">// to do...</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>2，函数字面量形式（即函数表达式）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 函数字面量</span><br><span class=\"hljs-keyword\">var</span> foo = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-comment\">// to do...</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>还有一种是方式：函数构造法：var a = new Fun ()，技术角度来讲也是一个字面量形式。</p>\n<p>函数提升只针对具名函数，而对于赋值的匿名函数，并不会存在函数提升。</p>\n<h3 id=\"4-变量提升与函数提升的优先级\"><a class=\"markdownIt-Anchor\" href=\"#4-变量提升与函数提升的优先级\">#</a> 4 变量提升与函数提升的优先级</h3>\n<p>函数提升优先级高于变量提升，且不会被同名变量声明覆盖，但是会被变量赋值后覆盖。</p>\n<h3 id=\"5-为什么有变量提升\"><a class=\"markdownIt-Anchor\" href=\"#5-为什么有变量提升\">#</a> 5 为什么有变量提升</h3>\n<p>JavaScript 作为脚本语言，不同于编程语言的一点是没有编译过程，但是它需要脚本解释器边解析边执行，而脚本解释器在解释执行代码前会先扫描一遍，这个过程就是 “预解析” 过程。</p>\n<p>J S 运行阶段包括预解析阶段和运行阶段。</p>\n<p>预解析阶段：</p>\n<p>​\t变量提升</p>\n<p>​\t函数提升</p>\n<p>执行阶段：</p>\n<p>​\t创建一个执行上下文 (execution context)，函数压栈，生成 active object (活动对象)</p>\n<p>​\t执行 / 解释上下文中的 function，为变量赋值</p>\n<p>预解析需要<strong>注意</strong>如下几个问题：</p>\n<ol>\n<li>预编译首先是全局预编译，函数体未调用时是不进行预编译的。</li>\n<li>只有 var 和 function 声明会被提升。</li>\n<li>在所在的作用域会被提升，不会扩展到其他的作用域。</li>\n<li>预编译后会顺序执行代码。</li>\n</ol>\n",
            "tags": [
                "JavaScript"
            ]
        },
        {
            "id": "http://example.com/2022/06/15/4001_JavaScript/",
            "url": "http://example.com/2022/06/15/4001_JavaScript/",
            "title": "JavaScript",
            "date_published": "2022-06-15T11:12:03.000Z",
            "content_html": "<p>🌸  <span style=\"font-size:bold;color:purple\">Welcome to XGG &amp; blog!</span><br>\n🔭  <span style=\"font-size:bold;color:purple\">When you have eliminated the impossible,whatever remains,however improbable,must be the truth.</span><br>\n📫  <span style=\"font-size:initial;color:purple\">If you get any problems when looking blog,you can find the answer in <a href=\"https://juejin.cn/user/2784392994882045\">稀土掘金</a> or you can ask me on <a href=\"https://github.com/LuckyWishes\">GitHub</a>.</span></p>\n<hr />\n<h5 id=\"函数的this绑定\"><a class=\"markdownIt-Anchor\" href=\"#函数的this绑定\">#</a> 函数的 this 绑定</h5>\n<ol>\n<li>\n<p>全局作用域下</p>\n<ol>\n<li>\n<p>浏览器环境：全局作用域下 <code>this</code>  绑定 window</p>\n</li>\n<li>\n<p>node 环境： <code>空对象&#123;&#125;</code></p>\n<ol>\n<li>执行步骤：首先将要执行的 js 文件作为模块，然后进行加载编译，此时将 js 代码所有文件放入一个函数中，执行该函数，但是该函数调用 <code>call()</code> , 在调用时向 <code>call()</code>  中传入一个空对象绑定为 <code>this</code>  即 <code>执行函数.call(&#123;&#125;)</code></li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p><em>函数作用域下</em> <code>this</code>  指向</p>\n<ol>\n<li>\n<p>函数在被调用时，JavaScript 会默认给 this 绑定一个值，this 指向与函数所处位置 (<strong>函数定义位置</strong>) 无关，与<strong>函数被调用的方式</strong>及调用位置有关，<strong>this 是在运行时被绑定</strong></p>\n</li>\n<li>\n<p><strong>默认绑定</strong></p>\n<ol>\n<li>\n<p>独立函数调用 <code>this</code>  指向的是全局对象 <code>window</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>);<br>&#125;<br><span class=\"hljs-keyword\">var</span> obj1 = &#123;<br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;obj1&quot;</span>,<br>  <span class=\"hljs-attr\">foo</span>: foo<br>&#125;<br><span class=\"hljs-comment\">// 将obj1的foo赋值给bar</span><br><span class=\"hljs-keyword\">var</span> bar = obj1.<span class=\"hljs-property\">foo</span>;<br><span class=\"hljs-title function_\">bar</span>();<br></code></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li>\n<p><strong>隐式绑定</strong></p>\n<ol>\n<li>\n<p>通过某个对象进行调用，即调用位置中是<strong>通过某个对象发起的函数调用</strong> (谁发起函数调用 this 就绑定谁)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>);<br>&#125;<br><span class=\"hljs-keyword\">var</span> test = &#123;<br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;test&quot;</span>,<br>  <span class=\"hljs-attr\">foo</span>: foo<br>&#125;<br><span class=\"hljs-keyword\">var</span> obj1 = &#123;<br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;obj1&quot;</span>,<br>  <span class=\"hljs-attr\">test</span>: test<br>&#125;<br><span class=\"hljs-keyword\">var</span> obj2 = &#123;<br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;obj2&quot;</span>,<br>  <span class=\"hljs-attr\">obj1</span>: obj1<br>&#125;<br>obj2.<span class=\"hljs-property\">obj1</span>.<span class=\"hljs-property\">test</span>.<span class=\"hljs-title function_\">foo</span>();<span class=\"hljs-comment\">//test对象</span><br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>object.fn()</code> ：object 对象会被 js 引擎绑定到 fn 函数中的 this 上</p>\n</li>\n<li>\n<p>隐式绑定的前提条件</p>\n<ol>\n<li>必须在调用的对象内部有一个对函数的引用（比如一个属性）</li>\n<li>如果没有这样的引用，在进行调用时，会报找不到该函数的错误</li>\n<li>正是通过这个引用，间接的将 this 绑定到了这个对象上</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p><strong>显示绑定</strong></p>\n<ol>\n<li>\n<p><code>call()</code></p>\n<ol>\n<li>第一个参数为绑定对象，第二个参数为参数列表 (剩余参数形式)</li>\n</ol>\n</li>\n<li>\n<p><code>apply()</code></p>\n<ol>\n<li>第一个参数为绑定对象，第二个参数为参数列表 (数组形式)</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-params\">num1,num2,num3</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(num1+num2+num3,<span class=\"hljs-variable language_\">this</span>);<br>&#125;<br>sum.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-string\">&quot;call&quot;</span>,<span class=\"hljs-number\">20</span>,<span class=\"hljs-number\">30</span>,<span class=\"hljs-number\">40</span>);<span class=\"hljs-comment\">//剩余参数形式</span><br>sum.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-string\">&quot;apply&quot;</span>,[<span class=\"hljs-number\">20</span>,<span class=\"hljs-number\">30</span>,<span class=\"hljs-number\">40</span>]);<span class=\"hljs-comment\">//数组形式</span><br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>bind()</code></p>\n<ol>\n<li>第一个参数为绑定对象，第二个参数为参数列表 (剩余参数形式), <code>bind</code>  返回为一个新的函数</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>);<br>&#125;<br><span class=\"hljs-comment\">// 默认绑定和显示绑定bind冲突：优先级（显示绑定）</span><br><span class=\"hljs-keyword\">var</span> newFoo = foo.<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-string\">&quot;aaaa&quot;</span>);<br><span class=\"hljs-title function_\">newFoo</span>();<br></code></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li>\n<p><strong>new 绑定</strong></p>\n<ol>\n<li>使用 new 关键字来调用函数执行如下的操作\n<ol>\n<li>创建一个全新的对象，<strong>并将该对象赋值给 this，函数最后返回该对象</strong></li>\n<li>这个新对象会被执行 prototype 连接</li>\n<li>这个新对象会绑定到函数调用的 this 上（this 的绑定在这个步骤完成）</li>\n<li>如果函数没有返回其他对象，表达式会返回这个新对象</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p><strong>内置函数绑定</strong></p>\n<ol>\n<li>\n<p><code>setTimeout</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 因为setTimeout内部实现函数调用时为独立函数调用，所以打印this时指向window</span><br><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>)&#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>);  <span class=\"hljs-comment\">//window</span><br>&#125;, <span class=\"hljs-number\">2000</span>);<br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>数组.forEach/map/filter/find等高阶函数</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> names = [<span class=\"hljs-string\">&quot;aaa&quot;</span>,<span class=\"hljs-string\">&quot;bbb&quot;</span>,<span class=\"hljs-string\">&quot;ccc&quot;</span>,<span class=\"hljs-string\">&quot;ddd&quot;</span>];<br><span class=\"hljs-comment\">// 函数直接独立调用指向window</span><br>names.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">item</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(item,<span class=\"hljs-variable language_\">this</span>);<br>&#125;)<br><span class=\"hljs-comment\">// forEach函数接收两个参数，第一个参数为一个函数，第二个参数为this绑定对象</span><br>names.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">item</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(item,<span class=\"hljs-variable language_\">this</span>);<br>&#125;,<span class=\"hljs-string\">&quot;forEach&quot;</span>)<br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>div的点击</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 2、监听box盒子的点击,内部函数调用实现为：隐式this绑定调用进行打印即boxDiv.onclick()形式调用</span><br><span class=\"hljs-keyword\">const</span> boxDiv = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&quot;.box&quot;</span>);<br><span class=\"hljs-comment\">// 1.方式一：该方式添加监听事件会进行覆盖，也就是后面一个监听事件会覆盖前面一个，只生效一个最后一个事件</span><br>boxDiv.<span class=\"hljs-property\">onclick</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>);<br>&#125;<br><span class=\"hljs-comment\">// 2.方式二：不会进行事件覆盖，会将函数收集到一个数组里面，执行时进行遍历</span><br><span class=\"hljs-comment\">// 内部函数调用实现为：call()方式，即fn.call(boxDiv)</span><br>boxDiv.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;click&quot;</span>,<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>);<br>&#125;)<br>boxDiv.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;click&quot;</span>,<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>);<br>&#125;)<br>boxDiv.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;click&quot;</span>,<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>);<br>&#125;)<br></code></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n",
            "tags": [
                "JavaScript"
            ]
        },
        {
            "id": "http://example.com/2019/01/13/4000_JavaScript/",
            "url": "http://example.com/2019/01/13/4000_JavaScript/",
            "title": "JavaScript",
            "date_published": "2019-01-13T06:12:03.000Z",
            "content_html": "<p>🌸  <span style=\"font-size:bold;color:purple\">Welcome to XGG &amp; blog!</span><br>\n🔭  <span style=\"font-size:bold;color:purple\">When you have eliminated the impossible,whatever remains,however improbable,must be the truth.</span><br>\n📫  <span style=\"font-size:initial;color:purple\">If you get any problems when looking blog,you can find the answer in <a href=\"https://juejin.cn/user/2784392994882045\">稀土掘金</a> or you can ask me on <a href=\"https://github.com/LuckyWishes\">GitHub</a>.</span></p>\n<hr />\n<h2 id=\"1javascript介绍\"><a class=\"markdownIt-Anchor\" href=\"#1javascript介绍\">#</a> 1.JavaScript 介绍</h2>\n<h3 id=\"1javascript应用\"><a class=\"markdownIt-Anchor\" href=\"#1javascript应用\">#</a> 1.JavaScript 应用</h3>\n<ol>\n<li>web 端开发</li>\n<li>移动端开发</li>\n<li>小程序端开发</li>\n<li>桌面应用开发</li>\n<li>后端开发</li>\n</ol>\n<h2 id=\"2javascript运行环境\"><a class=\"markdownIt-Anchor\" href=\"#2javascript运行环境\">#</a> 2.JavaScript 运行环境</h2>\n<h3 id=\"1浏览器工作原理\"><a class=\"markdownIt-Anchor\" href=\"#1浏览器工作原理\">#</a> 1. 浏览器工作原理</h3>\n<ol>\n<li>\n<p>浏览器内核</p>\n<ol>\n<li>Gecko：早期被 Netscape 和 Mozilla、Firefox 浏览器使用，代码完全公开，因此，其可开发程度很高，全世界的程序员都可以为其编写代码，增加功能</li>\n<li>Trident：微软开发的一种排版引擎，被 IE4~IE11 浏览器使用，但是 Edge 浏览器已经转向 Blink</li>\n<li>Webkit：苹果基于 KHTML 开发、开源的，用于 Safari 浏览器，Google Chrome 之前也在使用</li>\n<li>Blink：Google 谷歌基于 webkit 内核开发的，目前应用于 Google Chrome、Edge、Opera 等</li>\n<li>Presto:Opera 浏览器曾经使用过，特点是渲染速度的优化达到了极致，然而代价是牺牲了网页的兼容性</li>\n<li>内核也称排班引擎、浏览器引擎、页面渲染引擎、样板引擎</li>\n</ol>\n</li>\n<li>\n<p>内核工作原理</p>\n<ol>\n<li>浏览器渲染过程，需要将 JavaScript 代码转换为机器语言后交给 CPU 执行<img src=\"../../all_photo/image-20220602085625470.png\" alt=\"image-20220602085625470\"></li>\n</ol>\n</li>\n<li>\n<p><code>Webkit浏览器</code> 内核，由 WebCore 与 JavaScriptCore 两部分组成</p>\n<ol>\n<li>WebCore：负责 HTML、CSS 解析、布局、渲染等相关工作</li>\n<li>JavaScriptCore：解析、执行 JavaScript 代码</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"2v8引擎工作原理\"><a class=\"markdownIt-Anchor\" href=\"#2v8引擎工作原理\">#</a> 2.V8 引擎工作原理</h3>\n<ol>\n<li>\n<p>JavaScript 引擎（V8 引擎是 Google 开发）</p>\n<ol>\n<li>SpiderMonkey：第一款 JavaScript 引擎，由 BrendanEich 开发（也就是 JavaScript 作者）</li>\n<li>Chakra：微软开发，用于 IT 浏览器</li>\n<li>JavaScriptCore：WebKit 中的 JavaScript 引擎，Apple 公司开发</li>\n<li>V8 引擎：Google 开发的强大 JavaScript 引擎，也帮助 Chrome 从众多浏览器中脱颖而出</li>\n</ol>\n</li>\n<li>\n<p>V8 引擎工作原理</p>\n<ol>\n<li>\n<p>V8 定义：C<ins> 编写的 Google 开源高性能 JavaScript 和 webAssembly 引擎，它用于 Chrome 和 Node.js，在很多环境及平台下可以运行，也可以单独运行，也可以嵌入 C</ins> 应用程序中运行</p>\n</li>\n<li>\n<p>Parse：转换器，Parse 模块会将 JavaScript 代码转换成 AST (抽象语法树), 这是因为解释器并不直接认识 JavaScript 代码，如果函数没有被调用，那么是不会被转换成 AST (词法分析: <code>Scanner</code>  转换生成多个 tokens:[{type:‘keyword’,value:‘const’}] 等、语法分析、)</p>\n<blockquote>\n<p>注意:js 代码转换为 AST 抽象语法树网站 (<a href=\"https://astexplorer.net/\">https://astexplorer.net/</a>)</p>\n</blockquote>\n</li>\n<li>\n<p>lgnition：解释器，会将 AST 转换成 ByteCode（字节码）, 因为编写代码运行在具体什么样环境并不清楚，所以需要将该代码转换为字节码，字节码可以运行在各个环境，同时会收集 TurboFan 优化所需要的信息 (比如函数参数的类型信息，有了类型才能进行真实的运算), 如果函数只调用一次，Ignition 会解释执行字节码 ByteCode</p>\n</li>\n<li>\n<p>TurboFan：编译器，可以将字节码编译为 CPU 可以直接执行的机器码；如果一个函数被多次调用，那么就会被标记为 <code>热点函数</code> ，那么就会经过 TurboFan 转换成优化的机器码，提高代码的执行性能；但是机器码实际上也会被还原为 ByteCode，这是因为如果后续执行函数的过程中，类型发生了变化（比如 sum 函数原来执行的是 number 类型，后来执行变成了 string 类型），之前优化的机器码并不能正确的处理运算，就会逆向的经过 <code>Deoptimization</code>  优化转换成字节码，继续进行执行 (从这一点也可以看出 typescript 代码运行效率会好一些，因为在编写时就已经确定参数的类型，减少了逆向转换为字节码再一次进行运行编译为汇编语言然后机器代码，越过这个过程就会快一些)</p>\n</li>\n<li>\n<p>Orinoco：垃圾回收，将程序中不需要的内存回收？？？</p>\n</li>\n<li>\n<p>执行原理过程</p>\n<p><img src=\"../../all_photo/image-20220704154715013.png\" alt=\"image-20220704154715013\"></p>\n</li>\n<li>\n<p>官方执行原理过程</p>\n<p><img src=\"../../all_photo/image-20220704160009294.png\" alt=\"image-20220704160009294\"></p>\n</li>\n<li>\n<p>JavaScript 源码解析过程</p>\n<ol>\n<li>Blink 将源码交给 V8 引擎，Stream 获取到源码并且进行编码转换</li>\n<li>Scanner 会进行词法分析（lexical analysis），词法分析会将代码转换成各种 tokens</li>\n<li>接下来 tokens 会被转换成 AST 树，经过 Parser 和 PreParser\n<ol>\n<li>Parser 就是直接将 tokens 转成 AST 树架构</li>\n<li>PreParser 称之为预解析\n<ol>\n<li>因为并不是所有的 JavaScript 代码，在一开始时就会被执行。那么对所有的 JavaScript 代码进行解析，必然会影响网页的运行效率</li>\n<li>所以 V8 引擎就实现了 Lazy Parsing（延迟解析）的方案，它的作用是将不必要的函数进行预解析，也就是只解析暂时需要的内容，而对<strong>函数的全量解析</strong>是在<strong>函数被调用时</strong>才会进行</li>\n<li>比如我们在一个函数 outer 内部定义了另外一个函数 inner，那么 inner 函数就会进行预解析，生成 AST 树后，会被 Ignition 转成字节码（bytecode）, 之后的过程就是代码的执行过程（后续会详细分析）</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p>JavaScript 源码执行具体操作</p>\n<ol>\n<li>初始化全局对象\n<ol>\n<li>js 引擎会在执行代码之前，会在堆内存中创建一个全局对象：Global Object（GO）</li>\n<li>该对象所有的作用域（scope）都可以访问，里面会包含 Date、Array、String、Number、setTimeout、setInterval 等等，其中有一个 window 属性指向自己</li>\n</ol>\n</li>\n<li>执行上下文栈 (调用栈)\n<ol>\n<li>js 引擎内部有一个执行上下文栈 (Execution Context Stack, 简称 ECS), 它是用于执行代码的调用栈</li>\n<li>该栈执行的是全局代码块，全局的代码块为了执行会构建一个 Global Execution Context (GEC: 全局执行上下文),GEC 会被放入到 ECS 中执行</li>\n<li>GEC 被放入到 ECS 中里面包含两部分内容\n<ol>\n<li>在代码执行前，在 parser 转成 AST 的过程中，会将全局定义的变量、函数等加入到 GlobalObject 中，但是并不会赋值，这个过程也称之为变量的作用域提升（hoisting）</li>\n<li>在代码执行中，对变量赋值，或者执行其他的函数</li>\n</ol>\n</li>\n<li>在执行的过程中执行到一个函数时，就会根据函数体创建一个函数执行上下文（Functional Execution Context，简称 FEC），并且压入到 EC Stack 中</li>\n<li>FEC 中包含三部分内容\n<ol>\n<li>在解析函数成为 AST 树结构时，会创建一个 Activation Object (AO):AO 中包含形参、arguments、函数定义和指向函数对象、定义的变量（<strong>VO:AO</strong>）</li>\n<li>作用域链：由 VO（在函数中就是 AO 对象）和父级 VO 组成，查找时会一层层查找</li>\n<li>this 绑定的值：根据不同的情况绑定 this</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>变量环境和记录 ( <code>作用域链考点</code> )\n<ol>\n<li>概念\n<ol>\n<li>VO：全局变量对象，创建执行上下文时与之关联的会有一个变量对象，该上下文中的所有变量和函数全都保存在这个对象中</li>\n<li>GO：全局对象，进入到一个执行上下文时，此执行上下文中的变量和函数都可以被访问 (全局)</li>\n<li>AO：私有变量对象 (函数即将被执行，还没有还执行)，进入到一个执行上下文时，此执行上下文中的变量和函数都可以被访问 (局部)</li>\n<li>GEC (global excution context) 全局执行上下文：执行全局代码，FEC (function excution context) 函数执行上下文：执行函数代码</li>\n<li><strong>函数的作用域与函数定义位置有关，与调用位置无关</strong></li>\n</ol>\n</li>\n<li>早期 ECMA 版本规范：每一个执行上下文被关联到一个变量对象 (variable,VO), 在源代码中的变量和函数声明会被作为属性添加到 VO 中，对于函数来说，参数也会被添加到 VO 中</li>\n<li>在最新的 ECMA 的版本规范中，已经修改不称作 VO、GO、AO 等，而是称为变量环境，每添加的变量、函数叫作环境记录。每一个执行上下文会关联到一个 <code>变量环境</code>  (VariableEnvironment 简称 VE) 中，在执行代码中变量和函数的声明会作为 <code>环境记录</code>  (Environment Record) 添加到变量环境中，对于函数来说，参数也会被作为环境记录添加到变量环境中</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"3javascript内存原理\"><a class=\"markdownIt-Anchor\" href=\"#3javascript内存原理\">#</a> 3.JavaScript 内存原理</h3>\n<ol>\n<li>内存管理\n<ol>\n<li>内存的管理有如下的生命周期\n<ol>\n<li>分配所申请的内存空间</li>\n<li>使用所分配的内存空间</li>\n<li>不使用时进行释放</li>\n</ol>\n</li>\n<li>管理内存的方式\n<ol>\n<li>手动管理内存：C、C++</li>\n<li>自动管理内存：Java、JavaScript、python、Swift、Dart</li>\n</ol>\n</li>\n<li>内存分配\n<ol>\n<li>JS 对于基本数据类型内存的分配会在执行时，直接在栈空间进行分配</li>\n<li>对于复杂数据类型内存的分配会在堆内存中开辟一块空间，并且将这块空间的指针返回值变量引用</li>\n</ol>\n</li>\n<li>JS 的垃圾回收，Garbage Collection，简称<strong> GC</strong>\n<ol>\n<li>不再使用的对象，称之为垃圾，需要被回收释放更多的内存空间</li>\n<li>Java 的运行环境 JVM，JavaScript 的运行环境 js 引擎都会有内存垃圾回收器</li>\n<li>GC 算法\n<ol>\n<li>引用计数：内存中存在一个引用计数，retain count：默认为 0，缺点可能会产生循环引用</li>\n<li><strong>标记清除</strong>：设置一个根对象 (root object), 垃圾回收器会定期从这个根开始，找所有从开始有引用的对象，对于没有引用的对象，就认为是不可用对象</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>常见 GC 内存算法\n<ol>\n<li>JavaScript 垃圾回收</li>\n<li>引用计数算法</li>\n<li>标记清除算法</li>\n<li>标记整理算法</li>\n<li>分代回收算法</li>\n</ol>\n</li>\n<li>V8 引擎内存管理\n<ol>\n<li>V8 的分代算法</li>\n<li>V8 的内存分配</li>\n<li>新生代对象回收</li>\n<li>旧生代对象回收</li>\n</ol>\n</li>\n<li>Performmance 调试</li>\n<li>JavaScript 内存泄漏</li>\n<li>严格模式\n<ol>\n<li>概念\n<ol>\n<li>严格模式是一种具有限制性的 JavaScript 模式，从而使代码隐式的脱离了 <code>懒散（sloppy）模式</code></li>\n<li>支持严格模式的浏览器在检测到代码中有严格模式时，会以更加严格的方式对代码进行检测和执行</li>\n<li>严格模式对正常的 JavaScript 语义进行了一些限制\n<ol>\n<li>严格模式通过抛出错误来消除一些原有的静默（silent）错误</li>\n<li>严格模式让 JS 引擎在执行代码时可以进行更多的优化（不需要对一些特殊的语法进行处理）</li>\n<li>严格模式禁用了在 ECMAScript 未来版本中可能会定义的一些语法</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>开启严格模式\n<ol>\n<li>支持在 js 文件中开启严格模式</li>\n<li>支持对某一个函数开启严格模式</li>\n<li>严格模式通过在文件或者函数开头使用 use strict 来开启</li>\n</ol>\n</li>\n<li>严格模式限制\n<ol>\n<li>禁止意外创建全局变量</li>\n<li>不允许函数有相同的参数名称</li>\n<li>出现静默错误</li>\n<li>不允许使用原先的八进制格式</li>\n<li>with 语句不允许使用</li>\n<li>eval 函数不会向上引用变量 (不会再向上层作用域添加变量)</li>\n<li>严格模式下试图删除不可删除的属性</li>\n<li>严格模式下，this 绑定不会默认转成对象</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"4javascript事件循环\"><a class=\"markdownIt-Anchor\" href=\"#4javascript事件循环\">#</a> 4.JavaScript 事件循环</h3>\n<ol>\n<li>浏览器的进程模式\n<ol>\n<li>进程</li>\n<li>线程</li>\n<li>JavaScript 线程</li>\n</ol>\n</li>\n<li>浏览器的事件循环\n<ol>\n<li>宏任务 macrotask</li>\n<li>微任务 microtask</li>\n<li>常见面试题</li>\n</ol>\n</li>\n<li>Node 的事件循环\n<ol>\n<li>libuv</li>\n<li>阻塞 IO</li>\n<li>非阻塞 IO</li>\n<li>宏任务 macrotask</li>\n<li>微任务 microtask</li>\n<li>常见面试题</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"3javascript作用域和函数\"><a class=\"markdownIt-Anchor\" href=\"#3javascript作用域和函数\">#</a> 3.JavaScript 作用域和函数</h2>\n<h3 id=\"1认识作用域\"><a class=\"markdownIt-Anchor\" href=\"#1认识作用域\">#</a> 1. 认识作用域</h3>\n<ol>\n<li>\n<p>认识作用域</p>\n<ol>\n<li>JavaScript 编译、执行</li>\n<li>深入理解作用域</li>\n<li>作用域的嵌套</li>\n</ol>\n</li>\n<li>\n<p>词法作用域</p>\n<ol>\n<li>\n<p>认识词法分析</p>\n</li>\n<li>\n<p>eval 函数</p>\n<ol>\n<li>eval 是一个特殊的函数，可以将传入的字符串当作 JavaScript 代码来运行</li>\n<li>不建议在开发中使用\n<ol>\n<li>eval 代码可读性较差</li>\n<li>eval 是一个字符串，可能在执行过程中被篡改，造成恶意攻击</li>\n<li>eval 的执行必须经过 JS 解释器，不能被 JS 引擎优化</li>\n</ol>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> jsString = <span class=\"hljs-string\">&#x27;var message = &quot;Hello World~~&quot;;console.log(message);&#x27;</span>;<br><span class=\"hljs-built_in\">eval</span>(jsString);<br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p>with 关键字</p>\n<ol>\n<li><code>with</code>  的使用，但不推荐使用，在严格模式下会报错</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// &quot;use strict&quot;</span><br><span class=\"hljs-keyword\">var</span> message = <span class=\"hljs-string\">&quot;Hello world!&quot;</span>;<br><span class=\"hljs-keyword\">var</span> object = &#123;<br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;tests&quot;</span>,<br>  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">12</span>,<br>  <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">&quot;您好&quot;</span><br>&#125;;<br><span class=\"hljs-comment\">// with语句:可以形成自己的作用域</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">bar</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">with</span> (object) &#123;<br>      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(message);<br>    &#125;<br>  &#125;<br>  <span class=\"hljs-title function_\">bar</span>();<br>&#125;<br><span class=\"hljs-title function_\">foo</span>();<br></code></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li>\n<p>作用域提升</p>\n<ol>\n<li>编译器中变量声明和提升</li>\n<li>函数和变量的提升</li>\n</ol>\n</li>\n<li>\n<p>块级作用域</p>\n<ol>\n<li>with 作用域\n<ol>\n<li><code>with</code>  可以自己形成作用域，先查找传进来的对象，之后再去上层查找</li>\n</ol>\n</li>\n<li><code>try...catch...</code>  作用域</li>\n<li>let 变量声明</li>\n<li>const 变量声明</li>\n</ol>\n</li>\n<li>\n<p>作用域面试题</p>\n</li>\n</ol>\n<h3 id=\"2执行上下文\"><a class=\"markdownIt-Anchor\" href=\"#2执行上下文\">#</a> 2. 执行上下文</h3>\n<ol>\n<li>执行上下文\n<ol>\n<li>Global EC</li>\n<li>Function EC</li>\n<li>Eval EC</li>\n</ol>\n</li>\n<li>变量对象 VO\n<ol>\n<li>VO: 全局变量对象</li>\n<li>AO: 私有变量对象</li>\n<li>GO: 全局对象</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"3深入函数执行\"><a class=\"markdownIt-Anchor\" href=\"#3深入函数执行\">#</a> 3. 深入函数执行</h3>\n<ol>\n<li>\n<p><code>call/apply执行函数</code></p>\n</li>\n<li>\n<p>立即执行函数</p>\n</li>\n<li>\n<p><code>Scopechain</code></p>\n</li>\n<li>\n<p><strong> <code>深入闭包</code> </strong></p>\n<ol>\n<li>\n<p>补充</p>\n<ol>\n<li>高阶函数：一个函数接收另一个函数作为参数或者一个函数会作为另一个函数的返回值返回</li>\n<li><code>filter</code> : 过滤，接收一个<strong>返回布尔类型的函数为参数</strong>，并且该函数具有三个参数分别为数组中的元素、数组中的元素的下标、数组本身</li>\n<li><code>map</code> : 映射，</li>\n<li><code>forEach</code> : 迭代遍历，无返回值</li>\n<li><code>find</code> : 查找的为一个对象</li>\n<li><code>findIndex</code> : 查找的为对象索引值</li>\n<li><code>reduce</code> : 累加计算</li>\n<li>方法：对象里面的函数（特殊位置的函数），函数：独立的 function 称为函数</li>\n</ol>\n</li>\n<li>\n<p><code>闭包:Closure</code></p>\n<ol>\n<li>\n<p>维基百科：闭包又称词法闭包、函数闭包，是在支持头等函数的编程语言中，实现词法绑定的一种技术，闭包在实现上是一个结构体，它存储了一个函数和一个关联的环境，闭包和普通函数的区别在于，<strong>当捕捉闭包的时候，它的自由变量会在捕捉时被确定</strong>，这样即使脱离了捕捉时的上下文，它也能照常运行</p>\n</li>\n<li>\n<p>MDN：<strong>一个函数和对其周围状态 (词法环境) 的引用捆绑</strong>在一起 (说函数被引用包围)，这样的组合就是闭包，闭包让你可以在一个内层函数中访问到其外层函数的作用域，在 JavaScript 中，每当创建一个函数，闭包就会在函数创建时被创建出来</p>\n</li>\n<li>\n<p>个人理解：<strong>一个普通的函数，如果它可以访问到外层作用域的自由变量，那么这个函数就是一个闭包。从广义角度：(可以访问到) JavaScript 中的函数都是闭包；从狭义角度 (有访问到)：JavaScript 中的一个函数，若访问了外层作用域的自由变量，那么它就是一个闭包</strong></p>\n</li>\n<li>\n<p>闭包引起的内存泄漏</p>\n<ol>\n<li>使用完毕后本该销毁的内存而没有销毁继续存在称为内存泄露</li>\n<li>内存释放将其设置为 <code>null</code>  即可</li>\n</ol>\n</li>\n<li>\n<p>闭包中引用的自由变量</p>\n<ol>\n<li>AO 对象不会被销毁时，该对象里面被闭包引用的自由变量不会被销毁，没有引用的自由变量会被 js 引擎销毁</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">var</span> name = <span class=\"hljs-string\">&quot;GXX&quot;</span>;<br>  <span class=\"hljs-keyword\">var</span> age = <span class=\"hljs-number\">19</span>;<br>  <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">bar</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">debugger</span><br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(name);<br>    <span class=\"hljs-comment\">// 按照ECAM规范整个foo函数的AO对象不会删除，所以该对象中的age属性也应该存在，但是浏览器的js引擎即V8引擎会进行优化将其删除掉</span><br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(age);<span class=\"hljs-comment\">//bar函数中不访问变量age</span><br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> bar;<br>&#125;<br><span class=\"hljs-keyword\">var</span> fn = <span class=\"hljs-title function_\">foo</span>();<br><span class=\"hljs-title function_\">fn</span>();<br></code></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"4函数的this绑定\"><a class=\"markdownIt-Anchor\" href=\"#4函数的this绑定\">#</a> 4. 函数的 this 绑定</h3>\n<ol>\n<li>\n<p>全局作用域下</p>\n<ol>\n<li>\n<p>浏览器环境：全局作用域下 <code>this</code>  绑定 window</p>\n</li>\n<li>\n<p>node 环境： <code>空对象&#123;&#125;</code></p>\n<ol>\n<li>执行步骤：首先将要执行的 js 文件作为模块，然后进行加载编译，此时将 js 代码所有文件放入一个函数中，执行该函数，但是该函数调用 <code>call()</code> , 在调用时向 <code>call()</code>  中传入一个空对象绑定为 <code>this</code>  即 <code>执行函数.call(&#123;&#125;)</code></li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p><em>函数作用域下</em> <code>this</code>  指向</p>\n<ol>\n<li>\n<p>函数在被调用时，JavaScript 会默认给 this 绑定一个值，this 指向与函数所处位置 (<strong>函数定义位置</strong>) 无关，与<strong>函数被调用的方式</strong>及调用位置有关，<strong>this 是在运行时被绑定</strong></p>\n</li>\n<li>\n<p><strong>默认绑定</strong></p>\n<ol>\n<li>\n<p>独立函数调用 <code>this</code>  指向的是全局对象 <code>window</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>);<br>&#125;<br><span class=\"hljs-keyword\">var</span> obj1 = &#123;<br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;obj1&quot;</span>,<br>  <span class=\"hljs-attr\">foo</span>: foo<br>&#125;<br><span class=\"hljs-comment\">// 将obj1的foo赋值给bar</span><br><span class=\"hljs-keyword\">var</span> bar = obj1.<span class=\"hljs-property\">foo</span>;<br><span class=\"hljs-title function_\">bar</span>();<br></code></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li>\n<p><strong>隐式绑定</strong></p>\n<ol>\n<li>\n<p>通过某个对象进行调用，即调用位置中是<strong>通过某个对象发起的函数调用</strong> (谁发起函数调用 this 就绑定谁)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>);<br>&#125;<br><span class=\"hljs-keyword\">var</span> test = &#123;<br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;test&quot;</span>,<br>  <span class=\"hljs-attr\">foo</span>: foo<br>&#125;<br><span class=\"hljs-keyword\">var</span> obj1 = &#123;<br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;obj1&quot;</span>,<br>  <span class=\"hljs-attr\">test</span>: test<br>&#125;<br><span class=\"hljs-keyword\">var</span> obj2 = &#123;<br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;obj2&quot;</span>,<br>  <span class=\"hljs-attr\">obj1</span>: obj1<br>&#125;<br>obj2.<span class=\"hljs-property\">obj1</span>.<span class=\"hljs-property\">test</span>.<span class=\"hljs-title function_\">foo</span>();<span class=\"hljs-comment\">//test对象</span><br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>object.fn()</code> ：object 对象会被 js 引擎绑定到 fn 函数中的 this 上</p>\n</li>\n<li>\n<p>隐式绑定的前提条件</p>\n<ol>\n<li>必须在调用的对象内部有一个对函数的引用（比如一个属性）</li>\n<li>如果没有这样的引用，在进行调用时，会报找不到该函数的错误</li>\n<li>正是通过这个引用，间接的将 this 绑定到了这个对象上</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p><strong>显示绑定</strong></p>\n<ol>\n<li>\n<p><code>call()</code></p>\n<ol>\n<li>第一个参数为绑定对象，第二个参数为参数列表 (剩余参数形式)</li>\n</ol>\n</li>\n<li>\n<p><code>apply()</code></p>\n<ol>\n<li>第一个参数为绑定对象，第二个参数为参数列表 (数组形式)</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-params\">num1,num2,num3</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(num1+num2+num3,<span class=\"hljs-variable language_\">this</span>);<br>&#125;<br>sum.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-string\">&quot;call&quot;</span>,<span class=\"hljs-number\">20</span>,<span class=\"hljs-number\">30</span>,<span class=\"hljs-number\">40</span>);<span class=\"hljs-comment\">//剩余参数形式</span><br>sum.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-string\">&quot;apply&quot;</span>,[<span class=\"hljs-number\">20</span>,<span class=\"hljs-number\">30</span>,<span class=\"hljs-number\">40</span>]);<span class=\"hljs-comment\">//数组形式</span><br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>bind()</code></p>\n<ol>\n<li>第一个参数为绑定对象，第二个参数为参数列表 (剩余参数形式), <code>bind</code>  返回为一个新的函数</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>);<br>&#125;<br><span class=\"hljs-comment\">// 默认绑定和显示绑定bind冲突：优先级（显示绑定）</span><br><span class=\"hljs-keyword\">var</span> newFoo = foo.<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-string\">&quot;aaaa&quot;</span>);<br><span class=\"hljs-title function_\">newFoo</span>();<br></code></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li>\n<p><strong>new 绑定</strong></p>\n<ol>\n<li>使用 new 关键字来调用函数执行如下的操作\n<ol>\n<li>创建一个全新的对象，<strong>并将该对象赋值给 this，函数最后返回该对象</strong></li>\n<li>这个新对象会被执行 prototype 连接</li>\n<li>这个新对象会绑定到函数调用的 this 上（this 的绑定在这个步骤完成）</li>\n<li>如果函数没有返回其他对象，表达式会返回这个新对象</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p><strong>内置函数绑定</strong></p>\n<ol>\n<li>\n<p><code>setTimeout</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 因为setTimeout内部实现函数调用时为独立函数调用，所以打印this时指向window</span><br><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>)&#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>);  <span class=\"hljs-comment\">//window</span><br>&#125;, <span class=\"hljs-number\">2000</span>);<br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>数组.forEach/map/filter/find等高阶函数</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> names = [<span class=\"hljs-string\">&quot;aaa&quot;</span>,<span class=\"hljs-string\">&quot;bbb&quot;</span>,<span class=\"hljs-string\">&quot;ccc&quot;</span>,<span class=\"hljs-string\">&quot;ddd&quot;</span>];<br><span class=\"hljs-comment\">// 函数直接独立调用指向window</span><br>names.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">item</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(item,<span class=\"hljs-variable language_\">this</span>);<br>&#125;)<br><span class=\"hljs-comment\">// forEach函数接收两个参数，第一个参数为一个函数，第二个参数为this绑定对象</span><br>names.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">item</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(item,<span class=\"hljs-variable language_\">this</span>);<br>&#125;,<span class=\"hljs-string\">&quot;forEach&quot;</span>)<br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>div的点击</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 2、监听box盒子的点击,内部函数调用实现为：隐式this绑定调用进行打印即boxDiv.onclick()形式调用</span><br><span class=\"hljs-keyword\">const</span> boxDiv = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&quot;.box&quot;</span>);<br><span class=\"hljs-comment\">// 1.方式一：该方式添加监听事件会进行覆盖，也就是后面一个监听事件会覆盖前面一个，只生效一个最后一个事件</span><br>boxDiv.<span class=\"hljs-property\">onclick</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>);<br>&#125;<br><span class=\"hljs-comment\">// 2.方式二：不会进行事件覆盖，会将函数收集到一个数组里面，执行时进行遍历</span><br><span class=\"hljs-comment\">// 内部函数调用实现为：call()方式，即fn.call(boxDiv)</span><br>boxDiv.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;click&quot;</span>,<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>);<br>&#125;)<br>boxDiv.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;click&quot;</span>,<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>);<br>&#125;)<br>boxDiv.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;click&quot;</span>,<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>);<br>&#125;)<br></code></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p><strong>规则的优先级</strong></p>\n<ol>\n<li>\n<p><strong>new 绑定 &gt; 显示绑定 (bind/call/apply) &gt; 隐式绑定 (object.foo ()) &gt; 默认绑定 (独立函数调用)</strong></p>\n</li>\n<li>\n<p>默认规则 (独立调用) 的优先级最低</p>\n</li>\n<li>\n<p>显示绑定优先级高于隐式绑定</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> object = &#123;<br>  <span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">&quot;object&quot;</span>,<br>  <span class=\"hljs-attr\">foo</span>:<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>);<br>  &#125;<br>&#125;<br>object.<span class=\"hljs-title function_\">foo</span>();<br>object.<span class=\"hljs-property\">foo</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-string\">&quot;call&quot;</span>);<span class=\"hljs-comment\">//call()绑定</span><br>object.<span class=\"hljs-property\">foo</span>.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-string\">&quot;apply&quot;</span>);<span class=\"hljs-comment\">//apply()绑定</span><br><span class=\"hljs-keyword\">var</span> bar = object.<span class=\"hljs-property\">foo</span>.<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-string\">&quot;bind&quot;</span>);<br><span class=\"hljs-title function_\">bar</span>();<br><span class=\"hljs-comment\">//bind()绑定优先级比较</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>);<br>&#125;<br><span class=\"hljs-keyword\">var</span> object = &#123;<br>  <span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">&quot;object&quot;</span>,<br>  <span class=\"hljs-attr\">foo</span>:foo.<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-string\">&quot;bind&quot;</span>)<br>&#125;<br>object.<span class=\"hljs-title function_\">foo</span>();<br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p>new 绑定优先级高于隐式绑定</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> object = &#123;<br>  <span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">&quot;GXX&quot;</span>,<br>  <span class=\"hljs-attr\">foo</span>:<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>);<br>  &#125;<br>&#125;<br><span class=\"hljs-comment\">// new的优先级高于隐式绑定</span><br><span class=\"hljs-keyword\">var</span> fn = <span class=\"hljs-keyword\">new</span> object.<span class=\"hljs-title function_\">foo</span>();<br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p>new 绑定优先级高于 bind</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 结论：new关键字不能和apply/call一起来使用</span><br><span class=\"hljs-comment\">// new VS bind</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>);<br>&#125;<br><span class=\"hljs-keyword\">var</span> bar = foo.<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-string\">&quot;bind&quot;</span>);<br><span class=\"hljs-keyword\">var</span> object = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">bar</span>();<br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p>特殊情况 —— 忽略显示绑定</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>);<br>&#125;<br>foo.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-string\">&quot;call&quot;</span>);<br>foo.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-string\">&quot;apply&quot;</span>);<br><span class=\"hljs-comment\">// apply/call/bind:当传入null/undefined时，自动将this绑定成全局对象</span><br>foo.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-literal\">null</span>);<br>foo.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-literal\">undefined</span>); <br><span class=\"hljs-keyword\">var</span> fn = foo.<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-literal\">null</span>);<br><span class=\"hljs-comment\">// var fn = foo.bind(undefined);</span><br><span class=\"hljs-title function_\">fn</span>(); <br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p>特殊情况 —— 间接函数引用</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> object1 = &#123;<br>  <span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">&quot;object1&quot;</span>,<br>  <span class=\"hljs-attr\">foo</span>:<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>);<br>  &#125;<br>&#125;;<br><span class=\"hljs-keyword\">var</span> object2 = &#123;<br>  <span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">&quot;object2&quot;</span><br>&#125;;<br>object2.<span class=\"hljs-property\">bar</span> = object1.<span class=\"hljs-property\">foo</span>;<br>object2.<span class=\"hljs-title function_\">bar</span>();<span class=\"hljs-comment\">//打印object2对象</span><br><span class=\"hljs-comment\">// 立即执行函数(匿名函数)，当作独立函数调用，打印全局对象window</span><br>(object2.<span class=\"hljs-property\">bar</span> = object1.<span class=\"hljs-property\">foo</span>)();<br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p>特殊情况 ——ES6 箭头函数</p>\n<ol>\n<li>根据外层作用域来决定 <code>this</code>  指向</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> object =&#123;<br>  <span class=\"hljs-attr\">data</span>:[],<br>  <span class=\"hljs-attr\">getData</span>:<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br><span class=\"hljs-comment\">/*     // 发送网络请求，将结果放到上面data属性中</span><br><span class=\"hljs-comment\">    // 在箭头函数之前的解决方案</span><br><span class=\"hljs-comment\">    // 使用闭包</span><br><span class=\"hljs-comment\">    var _this = this;</span><br><span class=\"hljs-comment\">    setTimeout(() =&gt; &#123;</span><br><span class=\"hljs-comment\">      var result = [&quot;111&quot;,&quot;222&quot;,&quot;333&quot;,&quot;444&quot;];</span><br><span class=\"hljs-comment\">      _this.data = result;</span><br><span class=\"hljs-comment\">    &#125;, 2000); */</span><br>    <br>    <span class=\"hljs-comment\">// 箭头函数出现后</span><br>    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>      <span class=\"hljs-keyword\">var</span> result = [<span class=\"hljs-string\">&quot;111&quot;</span>,<span class=\"hljs-string\">&quot;222&quot;</span>,<span class=\"hljs-string\">&quot;333&quot;</span>,<span class=\"hljs-string\">&quot;444&quot;</span>];<br>      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">data</span> = result;<br>    &#125;, <span class=\"hljs-number\">2000</span>);<br>  &#125;<br>&#125;<br><span class=\"hljs-comment\">// 隐式绑定，将getData方法中的this指向object对象，则_this就为object对象，即可拿到result数据</span><br>object.<span class=\"hljs-title function_\">getData</span>();<br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>this指向面试题</code></p>\n<ol>\n<li>\n<p>对象花括号不是作用域</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> object = &#123;<br>\t<span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">&quot;test&quot;</span>,<br>\t<span class=\"hljs-attr\">foo</span>:<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)&#123;<br>\t<span class=\"hljs-comment\">//上层作用域为全局</span><br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p>箭头函数不看绑定，向上层作用域查找</p>\n</li>\n<li>\n<p>一定要看：<strong>执行时看是谁发起函数调用</strong></p>\n</li>\n</ol>\n</li>\n<li>\n<p>箭头函数</p>\n<ol>\n<li>介绍及简写语法练习</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p><strong> <code>call&amp;apply&amp;bind</code> </strong></p>\n<ol>\n<li>\n<p><code>call实现</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 给所有的函数添加一个hycall方法</span><br><span class=\"hljs-title class_\">Function</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">hycall</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">thisArg,...args</span>) &#123;<span class=\"hljs-comment\">//...args没有传入参数是一个空的数组</span><br>  <span class=\"hljs-comment\">// 第一步：获取哪一个函数调用hycall</span><br>  <span class=\"hljs-keyword\">var</span> fn = <span class=\"hljs-variable language_\">this</span>;<br>  <span class=\"hljs-comment\">// 第二步：对thisArg转成对象类型(防止传入的是非对象类型),使用thisArg对象时,当thisArg为字符串、数字、布尔等类型时需要进行转换为对应的对象</span><br>  thisArg = (thisArg !== <span class=\"hljs-literal\">null</span> &amp;&amp; thisArg !== <span class=\"hljs-literal\">undefined</span> &amp;&amp; thisArg == <span class=\"hljs-number\">0</span>) ? <span class=\"hljs-title class_\">Object</span>(thisArg) : <span class=\"hljs-variable language_\">window</span>;<br>  <span class=\"hljs-comment\">// 第三步：调用需要被执行的函数</span><br>  <span class=\"hljs-comment\">// 1、使用call实现</span><br>  <span class=\"hljs-comment\">// fn.call(thisArg);</span><br>  <span class=\"hljs-comment\">// 2、使用thisArg对象实现</span><br>  thisArg.<span class=\"hljs-property\">fn</span> = fn;<br>  <span class=\"hljs-keyword\">var</span> result = thisArg.<span class=\"hljs-title function_\">fn</span>(...args);<span class=\"hljs-comment\">//展开时至少是一个空的数组</span><br>  <span class=\"hljs-comment\">// delete thisArg.fn;</span><br>  <span class=\"hljs-comment\">// 第四步：将最终的结果返回出去</span><br>  <span class=\"hljs-keyword\">return</span> result;<br>&#125;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\">num1,num2</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;foo函数被执行&quot;</span>,<span class=\"hljs-variable language_\">this</span>,num1,num2);<br>&#125;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-params\">num1,num2</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;sum函数被执行&quot;</span>,<span class=\"hljs-variable language_\">this</span>,num1,num2);<br>  <span class=\"hljs-keyword\">return</span> num1 + num2;<br>&#125;<br>foo.<span class=\"hljs-title function_\">hycall</span>(&#123;&#125;);<br>foo.<span class=\"hljs-title function_\">hycall</span>(&#123;&#125;,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>);<br>foo.<span class=\"hljs-title function_\">hycall</span>(<span class=\"hljs-literal\">null</span>);<br>foo.<span class=\"hljs-title function_\">hycall</span>(<span class=\"hljs-literal\">undefined</span>,<span class=\"hljs-number\">6</span>,<span class=\"hljs-number\">6</span>);<br>sum.<span class=\"hljs-title function_\">hycall</span>(<span class=\"hljs-string\">&quot;hycall&quot;</span>,<span class=\"hljs-number\">9</span>,<span class=\"hljs-number\">9</span>);<br><span class=\"hljs-keyword\">var</span> result = <span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-number\">20</span>,<span class=\"hljs-number\">30</span>);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(result);<br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>apply实现</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Function</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">hyapply</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">thisArg,argArray</span>) &#123;<span class=\"hljs-comment\">//argArray没有传入参数是undefined</span><br>  <span class=\"hljs-comment\">// 第一步：获取那一个函数调用hyapply方法</span><br>  <span class=\"hljs-keyword\">var</span> fn = <span class=\"hljs-variable language_\">this</span>;<br>  <span class=\"hljs-comment\">// 第二步：保证传入都是对象类型</span><br>  thisArg = (thisArg !== <span class=\"hljs-literal\">null</span> &amp;&amp; thisArg !== <span class=\"hljs-literal\">undefined</span> &amp;&amp; thisArg == <span class=\"hljs-number\">0</span>) ? <span class=\"hljs-title class_\">Object</span>(thisArg) : <span class=\"hljs-variable language_\">window</span>;<br>  <span class=\"hljs-comment\">// 第三步：调用执行函数</span><br>  thisArg.<span class=\"hljs-property\">fn</span> = fn;<br>  <span class=\"hljs-comment\">// 判断是否传入参数</span><br>  <span class=\"hljs-comment\">// 方式一：!argArray为true没有参数，为false有参数</span><br>  <span class=\"hljs-keyword\">var</span> result = !argArray ? thisArg.<span class=\"hljs-title function_\">fn</span>() : thisArg.<span class=\"hljs-title function_\">fn</span>(...argArray);<br>  <span class=\"hljs-comment\">// 方式二：使用</span><br><br><span class=\"hljs-comment\">/*   // 方式三：使用或运算符</span><br><span class=\"hljs-comment\">  // argArray = argArray ? argArray:[]</span><br><span class=\"hljs-comment\">  argArray = argArray || [];</span><br><span class=\"hljs-comment\">  var result = thisArg.fn(...argArray); */</span><br>  <span class=\"hljs-keyword\">delete</span> thisArg.<span class=\"hljs-property\">fn</span>;<br>  <span class=\"hljs-keyword\">return</span> result;<br>&#125;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-params\">num1,num2</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;sum函数被调用了&quot;</span>,<span class=\"hljs-variable language_\">this</span>,num1,num2);<br>  <span class=\"hljs-keyword\">return</span> num1 + num2;<br>&#125;<br><span class=\"hljs-comment\">// 特殊情况一个参数也需要放入数组中</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\">num</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;foo函数被调用了&quot;</span>,<span class=\"hljs-variable language_\">this</span>,num);<br>  <span class=\"hljs-keyword\">return</span> num;<br>&#125;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">bar</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;bar函数被执行了&quot;</span>,<span class=\"hljs-variable language_\">this</span>);<br>&#125;<br>sum.<span class=\"hljs-title function_\">hyapply</span>(<span class=\"hljs-string\">&quot;test&quot;</span>,[<span class=\"hljs-number\">20</span>,<span class=\"hljs-number\">30</span>]);<br>sum.<span class=\"hljs-title function_\">hyapply</span>(<span class=\"hljs-literal\">null</span>,[<span class=\"hljs-number\">11</span>,<span class=\"hljs-number\">11</span>]);<br><span class=\"hljs-keyword\">var</span> res1 = sum.<span class=\"hljs-title function_\">hyapply</span>(<span class=\"hljs-string\">&quot;hyapply&quot;</span>,[<span class=\"hljs-number\">12</span>,<span class=\"hljs-number\">12</span>]);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res1);<br><span class=\"hljs-keyword\">var</span> res2 = foo.<span class=\"hljs-title function_\">hyapply</span>(<span class=\"hljs-string\">&quot;hyapply&quot;</span>,[<span class=\"hljs-number\">12</span>]);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res2);<br><span class=\"hljs-keyword\">var</span> res3 = bar.<span class=\"hljs-title function_\">hyapply</span>(<span class=\"hljs-string\">&quot;hyapply&quot;</span>);<br><span class=\"hljs-comment\">// 边界判断(edge case)</span><br>bar.<span class=\"hljs-title function_\">hyapply</span>(<span class=\"hljs-number\">0</span>);<br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>bind实现</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Function</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">hybind</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">thisArg, ...argArray</span>) &#123;<br>  <span class=\"hljs-comment\">// 第一步：获取到真实需要调用的函数</span><br>  <span class=\"hljs-keyword\">var</span> fn = <span class=\"hljs-variable language_\">this</span>;<br>  <span class=\"hljs-comment\">// 第二步：绑定this</span><br>  thisArg = (thisArg !== <span class=\"hljs-literal\">null</span> &amp;&amp; thisArg !== <span class=\"hljs-literal\">undefined</span>) ? <span class=\"hljs-title class_\">Object</span>(thisArg) : <span class=\"hljs-variable language_\">window</span>;<br>  <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">proxyFn</span>(<span class=\"hljs-params\">...args</span>) &#123;<br>  <span class=\"hljs-comment\">// 第三步：将函数放到thisArg中进行调用</span><br>    thisArg.<span class=\"hljs-property\">fn</span> = fn;<br>    <span class=\"hljs-comment\">// 特殊处理：对两个传入的参数进行合并</span><br>    <span class=\"hljs-keyword\">var</span> finalArgs = [...argArray, ...args]<br>    <span class=\"hljs-keyword\">var</span> result = thisArg.<span class=\"hljs-title function_\">fn</span>(...finalArgs);<br>    <span class=\"hljs-keyword\">delete</span> thisArg.<span class=\"hljs-property\">fn</span>;<br>  <span class=\"hljs-comment\">// 第四步：返回结果</span><br>    <span class=\"hljs-keyword\">return</span> result;<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> proxyFn;<br>&#125;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;foo函数被调用&quot;</span>, <span class=\"hljs-variable language_\">this</span>);<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">20</span>;<br>&#125;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-params\">num1, num2, num3, num4</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(num1, num2, num3, num4);<br>&#125;<br><span class=\"hljs-comment\">/* // 系统的bind调用</span><br><span class=\"hljs-comment\">var bar = foo.bind(&quot;bind&quot;);</span><br><span class=\"hljs-comment\">bar();</span><br><span class=\"hljs-comment\">// 传入参数的方式</span><br><span class=\"hljs-comment\">// 方式一</span><br><span class=\"hljs-comment\">var newSum = sum.bind(&quot;bind&quot;,11,22,33,44);</span><br><span class=\"hljs-comment\">newSum();</span><br><span class=\"hljs-comment\">// 方式二</span><br><span class=\"hljs-comment\">var newSum = sum.bind(&quot;bind&quot;);</span><br><span class=\"hljs-comment\">newSum(11,22,33,44);</span><br><span class=\"hljs-comment\">// 方式三</span><br><span class=\"hljs-comment\">var newSum = sum.bind(&quot;bind&quot;,11,22);</span><br><span class=\"hljs-comment\">newSum(33,44); */</span><br><span class=\"hljs-comment\">/* var bar = foo.hybind(&quot;hybind&quot;);</span><br><span class=\"hljs-comment\">var res = bar();</span><br><span class=\"hljs-comment\">console.log(res); */</span><br><span class=\"hljs-keyword\">var</span> newSum = sum.<span class=\"hljs-title function_\">hybind</span>(<span class=\"hljs-string\">&quot;hybind&quot;</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>);<br><span class=\"hljs-keyword\">var</span> res = <span class=\"hljs-title function_\">newSum</span>(<span class=\"hljs-number\">30</span>, <span class=\"hljs-number\">40</span>); <br></code></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li>\n<p><strong> <code>arguments</code> </strong></p>\n<ol>\n<li>\n<p>类数组对象 (array-like)，形式像是一个数组，本质上是一个对象，即为对象类型，不能使用数组的方法</p>\n</li>\n<li>\n<p><strong> <code>arguments参数转换数组</code> </strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\">num1,num2</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">arguments</span>);<br>  <span class=\"hljs-comment\">// arguments转换为数组类型方式</span><br><span class=\"hljs-comment\">/*   // 1、使用for循环遍历</span><br><span class=\"hljs-comment\">  var newArray1 = [];</span><br><span class=\"hljs-comment\">  for (let i = 0; i &lt; arguments.length; i++) &#123;</span><br><span class=\"hljs-comment\">    newArray1.push(arguments[i] * 10);</span><br><span class=\"hljs-comment\">  &#125;</span><br><span class=\"hljs-comment\">  console.log(newArray1); */</span><br><span class=\"hljs-comment\">/*   // 2、将arguments转换为array</span><br><span class=\"hljs-comment\">  var newArray2 = Array.prototype.slice.call(arguments);</span><br><span class=\"hljs-comment\">  console.log(newArray2);</span><br><span class=\"hljs-comment\">  var newArray3 = [].slice.call(arguments);</span><br><span class=\"hljs-comment\">  console.log(newArray3); */</span><br>  <span class=\"hljs-comment\">// 3、使用ES6的语法</span><br>  <span class=\"hljs-keyword\">var</span> newArray4 = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(<span class=\"hljs-variable language_\">arguments</span>);<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(newArray4);<br>  <span class=\"hljs-keyword\">var</span> newArray5 = [...<span class=\"hljs-variable language_\">arguments</span>];<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(newArray5);<br>&#125;<br><span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-number\">10</span>,<span class=\"hljs-number\">20</span>,<span class=\"hljs-number\">30</span>,<span class=\"hljs-number\">40</span>,<span class=\"hljs-number\">50</span>,<span class=\"hljs-number\">60</span>);<br><span class=\"hljs-comment\">/* // Array中slice方法实现     </span><br><span class=\"hljs-comment\">Array.prototype.hyslice = function (start,end) &#123;</span><br><span class=\"hljs-comment\">  var array = this;</span><br><span class=\"hljs-comment\">  start = start || 0;</span><br><span class=\"hljs-comment\">  end = end || array.length;</span><br><span class=\"hljs-comment\">  var newArray = [];</span><br><span class=\"hljs-comment\">  for (let i = start; i &lt; end; i++) &#123;</span><br><span class=\"hljs-comment\">    newArray.push(array[i]);</span><br><span class=\"hljs-comment\">  &#125;</span><br><span class=\"hljs-comment\">  return newArray;</span><br><span class=\"hljs-comment\">&#125;</span><br><span class=\"hljs-comment\">// var newArrayFinal = Array.prototype.hyslice.call([&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;],1,3);</span><br><span class=\"hljs-comment\">var newArrayFinal = Array.prototype.hyslice.call([&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;]);</span><br><span class=\"hljs-comment\">console.log(newArrayFinal); */</span><br><span class=\"hljs-comment\">/* // slice方法的使用</span><br><span class=\"hljs-comment\">var names = [&quot;111&quot;,&quot;222&quot;,&quot;333&quot;,&quot;444&quot;];</span><br><span class=\"hljs-comment\">console.log(names.slice(1,3)); */</span><br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p><strong> <code>箭头函数中没有arguments</code> </strong></p>\n<ol>\n<li>浏览器的全局作用域中没有 arguments</li>\n<li>node 环境下存在全局的 arguments</li>\n<li><strong>箭头函数可以使用剩余参数 <code>(...args)</code>  方式获取参数</strong></li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p>编程方式</p>\n<ol>\n<li>函数式编程范式</li>\n<li>面向对象式编程范式</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"5函数的柯里化\"><a class=\"markdownIt-Anchor\" href=\"#5函数的柯里化\">#</a> 5. 函数的柯里化</h3>\n<ol>\n<li>\n<p>纯函数</p>\n<ol>\n<li>\n<p>纯函数的条件</p>\n<ol>\n<li>确定的输入，一定会产生确定的输出</li>\n<li>函数在执行过程中，不能产生副作用</li>\n</ol>\n</li>\n<li>\n<p>副作用理解</p>\n<ol>\n<li>表示在执行一个函数时，除了返回函数值之外，还对调用函数产生了附加的影响，比如修改了全局变量，修改参数或者改变外部的存储</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// test是一个纯函数</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">test</span>(<span class=\"hljs-params\">info</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> &#123;<br>    ...info,<span class=\"hljs-comment\">//展开运算符，对原对象进行浅拷贝，并没有修改原对象</span><br>    <span class=\"hljs-attr\">age</span>:<span class=\"hljs-number\">10</span><br>  &#125;<br>&#125;<br><span class=\"hljs-keyword\">var</span> obj1 = &#123;<br>  <span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">&quot;111&quot;</span>,<br>  <span class=\"hljs-attr\">age</span>:<span class=\"hljs-number\">12</span><br>&#125;<br><span class=\"hljs-keyword\">var</span> obj2 = <span class=\"hljs-title function_\">test</span>(obj1);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj2);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj1);<br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p>纯函数的优势</p>\n<ol>\n<li>安心的编写和安心的使用</li>\n<li>只是单纯实现自己的业务逻辑即可，不需要关心传入的内容是如何获得的或者依赖其他的外部变量是否已经发生了修改</li>\n<li>你在用的时候，你确定你的输入内容不会被任意篡改，并且自己确定的输入，一定会有确定的输出</li>\n</ol>\n</li>\n<li>\n<p>纯函数的案例学习</p>\n<ol>\n<li>展开运算符，对原对象进行浅拷贝，并没有修改原对象</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p>柯里化是什么</p>\n<ol>\n<li>柯里化 (英语：Currying) 又译为 <code>卡瑞化</code> 或 <code>加里化</code></li>\n<li>只传递给函数<strong>一部分参数</strong>来调用它，让它返回<strong>一个函数</strong>去处理<strong>剩余的参数</strong></li>\n</ol>\n</li>\n<li>\n<p>实现柯里化</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//一般函数</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-params\">x,y,z</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> (x+y+z);<br>&#125;<br><span class=\"hljs-comment\">// 使用柯里化技术</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">bax</span>(<span class=\"hljs-params\">x</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">y</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">z</span>) &#123;<br>      <span class=\"hljs-keyword\">return</span> (x+y+z);<br>    &#125;<br>  &#125;<br>&#125;<br><span class=\"hljs-comment\">// 一般函数实现</span><br><span class=\"hljs-keyword\">var</span> result1 = <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">10</span>,<span class=\"hljs-number\">20</span>,<span class=\"hljs-number\">30</span>);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(result1);<br><span class=\"hljs-comment\">// 柯里化实现</span><br><span class=\"hljs-keyword\">var</span> result2 = <span class=\"hljs-title function_\">bax</span>(<span class=\"hljs-number\">11</span>)(<span class=\"hljs-number\">22</span>)(<span class=\"hljs-number\">33</span>);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(result2);<br><span class=\"hljs-comment\">// 简化柯里化操作</span><br><span class=\"hljs-keyword\">var</span> <span class=\"hljs-title function_\">foo</span> = (<span class=\"hljs-params\">x</span>) =&gt; <span class=\"hljs-function\">(<span class=\"hljs-params\">y</span>) =&gt;</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">z</span>) =&gt;</span> &#123;<br> <span class=\"hljs-keyword\">return</span> (x+y+z);<br>&#125;<br><span class=\"hljs-keyword\">var</span> result3 = <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-number\">22</span>)(<span class=\"hljs-number\">33</span>)(<span class=\"hljs-number\">44</span>);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(result3);<br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p><strong>柯里化函数的实现 (自动)</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-params\">x,y,z</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> (x+y+z);<br>&#125;<br><span class=\"hljs-comment\">// 柯里化函数的实现hyCurrying</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">hyCurrying</span>(<span class=\"hljs-params\">fn</span>) &#123;<br>  <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">curried1</span>(<span class=\"hljs-params\">...args1</span>) &#123;<br>    <span class=\"hljs-comment\">// 判断接收参数args和函数本身需要接收的参数数量是否一致</span><br>    <span class=\"hljs-comment\">// 当传入的参数大于等于函数需要的参数时，就执行函数</span><br>    <span class=\"hljs-keyword\">if</span> (args1.<span class=\"hljs-property\">length</span> &gt;= fn.<span class=\"hljs-property\">length</span>) &#123;<br>      <span class=\"hljs-comment\">//方式一</span><br>      <span class=\"hljs-comment\">// return fn(...args1);</span><br><span class=\"hljs-comment\">/*       // 方式二</span><br><span class=\"hljs-comment\">      return fn.call(this,...args1); */</span><br>      <span class=\"hljs-comment\">// 方式三</span><br>      <span class=\"hljs-comment\">// 此处this理解:若curryAdd.apply(&quot;test&quot;)即curried1中的this，把this绑定在fn函数中 </span><br>      <span class=\"hljs-keyword\">return</span> fn.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>,args1);<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>      <span class=\"hljs-comment\">// 没有达到函数所需参数数量时，需要返回一个新的函数，继续来接收参数</span><br>      <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">curried2</span>(<span class=\"hljs-params\">...args2</span>) &#123;<br>        <span class=\"hljs-comment\">// 接收到参数后，需要递归调用curried1来检查函数的参数个数是否达到所需参数的个数</span><br>        <span class=\"hljs-keyword\">return</span> curried1.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>,[...args1,...args2])<br>        <span class=\"hljs-comment\">// return curried1.apply(this,args.concat(args2))</span><br>      &#125;<br>      <span class=\"hljs-keyword\">return</span> curried2;<br>    &#125;<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> curried1;<br>&#125;<br><span class=\"hljs-keyword\">var</span> curryAdd = <span class=\"hljs-title function_\">hyCurrying</span>(add);<br><span class=\"hljs-keyword\">var</span> result1 = <span class=\"hljs-title function_\">curryAdd</span>(<span class=\"hljs-number\">10</span>,<span class=\"hljs-number\">20</span>,<span class=\"hljs-number\">30</span>);<br><span class=\"hljs-keyword\">var</span> result2 = <span class=\"hljs-title function_\">curryAdd</span>(<span class=\"hljs-number\">10</span>)(<span class=\"hljs-number\">20</span>)(<span class=\"hljs-number\">30</span>);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(result1);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(result2);<br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p>柯里化的应用</p>\n<ol>\n<li>\n<p><code>函数的职责单一</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 一般函数实现</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-params\">x, y, z</span>) &#123;<br>  <span class=\"hljs-attr\">x</span>: x + <span class=\"hljs-number\">2</span>;<br>  <span class=\"hljs-attr\">y</span>: y * <span class=\"hljs-number\">2</span>;<br>  <span class=\"hljs-attr\">z</span>: z * z;<br>  <span class=\"hljs-keyword\">return</span> (x + y + z)<br>&#125;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">10</span>,<span class=\"hljs-number\">20</span>,<span class=\"hljs-number\">30</span>));<br><span class=\"hljs-comment\">// 柯里化实现</span><br><span class=\"hljs-keyword\">var</span> <span class=\"hljs-title function_\">bar</span> = (<span class=\"hljs-params\">x</span>) =&gt; &#123;<br>  x+=<span class=\"hljs-number\">2</span>;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">y</span>) =&gt;</span> &#123;<br>    y*=<span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">z</span>) =&gt;</span> &#123;<br>      z*=z;<br>      <span class=\"hljs-keyword\">return</span> (x+y+z);<br>    &#125;<br>  &#125;<br>&#125;<br><span class=\"hljs-keyword\">var</span> result = <span class=\"hljs-title function_\">bar</span>(<span class=\"hljs-number\">10</span>)(<span class=\"hljs-number\">20</span>)(<span class=\"hljs-number\">30</span>);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(result);<br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>逻辑复用</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">/* // 23 + x = ？(x = 任意实数)</span><br><span class=\"hljs-comment\">// 一般函数实现</span><br><span class=\"hljs-comment\">function log(date, type, message) &#123;</span><br><span class=\"hljs-comment\">  console.log(`[$&#123;date.getHours()&#125;:$&#123;date.getMinutes()&#125;][$&#123;type&#125;]:[$&#123;message&#125;]`);</span><br><span class=\"hljs-comment\">&#125;</span><br><span class=\"hljs-comment\">log(new Date(), &quot;DEBUG&quot;, &quot;查询数据错误&quot;);</span><br><span class=\"hljs-comment\">log(new Date(), &quot;DEBUG&quot;, &quot;轮播图的错误&quot;);</span><br><span class=\"hljs-comment\">log(new Date(), &quot;DEBUG&quot;, &quot;查询表单错误&quot;); */</span><br><span class=\"hljs-comment\">// 柯里化实现</span><br><span class=\"hljs-keyword\">var</span> <span class=\"hljs-title function_\">log</span> = date =&gt; <span class=\"hljs-function\"><span class=\"hljs-params\">type</span> =&gt;</span> <span class=\"hljs-function\"><span class=\"hljs-params\">message</span> =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`[<span class=\"hljs-subst\">$&#123;date.getHours()&#125;</span>:<span class=\"hljs-subst\">$&#123;date.getMinutes()&#125;</span>][<span class=\"hljs-subst\">$&#123;type&#125;</span>]:[<span class=\"hljs-subst\">$&#123;message&#125;</span>]`</span>);<br>&#125;<br><span class=\"hljs-comment\">// 柯里化--复用时间逻辑</span><br><span class=\"hljs-keyword\">var</span> nowLog = <span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>());<br><span class=\"hljs-title function_\">nowLog</span>(<span class=\"hljs-string\">&quot;6666&quot;</span>)(<span class=\"hljs-string\">&quot;undefined&quot;</span>);<br><span class=\"hljs-comment\">// 柯里化--复用时间逻辑、错误信息逻辑</span><br><span class=\"hljs-keyword\">var</span> newAndDebug = <span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>())(<span class=\"hljs-string\">&quot;同一类型错误信息&quot;</span>);<br><span class=\"hljs-title function_\">newAndDebug</span>(<span class=\"hljs-string\">&quot;undefined&quot;</span>);<br><span class=\"hljs-title function_\">newAndDebug</span>(<span class=\"hljs-string\">&quot;null&quot;</span>);<br></code></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li>\n<p><code>组合函数</code></p>\n<ol>\n<li>\n<p>将多个函数组合起来，自动依次调用</p>\n</li>\n<li>\n<p>实现组合函数 (多个函数，多个参数)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">hyCompose</span>(<span class=\"hljs-params\">...fns</span>) &#123;<br>  <span class=\"hljs-comment\">// var length = fns.length;</span><br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; fns.<span class=\"hljs-property\">length</span>; i++) &#123;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> fns[i] !== <span class=\"hljs-string\">&#x27;function&#x27;</span>) &#123;<br>      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-title class_\">TypeError</span>(<span class=\"hljs-string\">&quot;Expected arguments are functions&quot;</span>);<br>    &#125;<br>  &#125;<br>  <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">compose</span>(<span class=\"hljs-params\">...args</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> index = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">var</span> result = fns.<span class=\"hljs-property\">length</span> ? fns[index].<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>,args):args;<br>    <span class=\"hljs-keyword\">while</span> (++index &lt; fns.<span class=\"hljs-property\">length</span>) &#123;<br>      result = fns[index].<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-variable language_\">this</span>,result);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> result;<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> compose;<br>&#125;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">double</span>(<span class=\"hljs-params\">num1</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> num1*<span class=\"hljs-number\">2</span>;<br>&#125;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">square</span>(<span class=\"hljs-params\">num2</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> num2**<span class=\"hljs-number\">2</span>;<br>&#125;<br><span class=\"hljs-keyword\">var</span> newFn = <span class=\"hljs-title function_\">hyCompose</span>(double,square);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">newFn</span>(<span class=\"hljs-number\">10</span>));<br></code></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"4javascript面向对象\"><a class=\"markdownIt-Anchor\" href=\"#4javascript面向对象\">#</a> 4.JavaScript 面向对象</h2>\n<h3 id=\"1深入理解对象\"><a class=\"markdownIt-Anchor\" href=\"#1深入理解对象\">#</a> 1. 深入理解对象</h3>\n<ol>\n<li>\n<p>补充</p>\n<ol>\n<li>JavaScript 支持多种编程范式，包括函数式编程、面向对象编程</li>\n<li>JavaScript 中的对象被设计成一组属性的无序集合，类似哈希表</li>\n<li>key 是一个标识符名称，value 可以是任意类型，也可以是其他对象或者函数类型</li>\n<li>如果值是一个函数，那么我们可以称之为是对象的方法</li>\n</ol>\n</li>\n<li>\n<p>对象的语法</p>\n<ol>\n<li>创建对象的两种方式\n<ol>\n<li>使用 <code>new</code>  关键字及 <code>Object类</code> 进行创建</li>\n<li>通过字面量进行创建</li>\n</ol>\n</li>\n<li>对象字面量</li>\n<li>对象的类型</li>\n<li>函数对象</li>\n</ol>\n</li>\n<li>\n<p>对象的内容</p>\n<ol>\n<li>\n<p>属性和方法定义</p>\n<ol>\n<li>对象方法补充\n<ol>\n<li><code>preventExtensions</code> : 禁止对象扩展新属性</li>\n<li><code>seal</code> : 密封对象，不允许配置和删除属性，禁止对象配置 / 删除里面的属性即设置 <code>configurable:false</code></li>\n<li><code>freeze</code> : 冻结对象，不允许修改现有的属性，使属性不可以修改即设置 <code>writable:false</code></li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p>对象属性描述符</p>\n<ol>\n<li>\n<p>想要对一个属性进行比较精准的操作控制，那么我们就可以使用属性描述符</p>\n</li>\n<li>\n<p>通过属性描述符可以精准的添加或修改对象的属性</p>\n</li>\n<li>\n<p>属性描述符需要使用 ** <code>Object.defineProperty()</code> ** 来对属性进行添加或者修改</p>\n</li>\n<li>\n<p><code>Object.defineProperty(obj,prop,descriptor)</code></p>\n<ol>\n<li><code>obj</code> : 需要定义属性的对象</li>\n<li><code>prop</code> : 将要定义或修改的属性名称或 <code>Symbol</code></li>\n<li><code>descriptor</code> : 将要定义或修改的<strong>属性描述符</strong></li>\n<li>该方式添加的属性默认是不可枚举的</li>\n</ol>\n</li>\n<li>\n<p><strong> <code>Object.defineProperties()</code> </strong>: 在一个对象上定义多个新的属性或修改现有属性，返回该对象</p>\n</li>\n<li>\n<p>属性描述符</p>\n<ol>\n<li>\n<p>数据属性描述符</p>\n<ol>\n<li><code>configurable</code> : 属性是否可以通过 delete 删除属性，是否可以修改它的特性，或者是否可以将它修改为存取属性描述符\n<ol>\n<li>当我们直接在一个对象上定义某个属性时，这个属性的 [Configurable] 为 true</li>\n<li>当我们通过属性描述符定义一个属性时，这个属性的 [Configurable] 默认为 false</li>\n</ol>\n</li>\n<li><code>enumerable</code> : 属性是否可以通过 for-in 或者 Object.keys () 返回该属性\n<ol>\n<li>当我们直接在一个对象上定义某个属性时，这个属性的 [[Enumerable]] 为 true</li>\n<li>当我们通过属性描述符定义一个属性时，这个属性的 [[Enumerable]] 默认为 false</li>\n</ol>\n</li>\n<li><code>value</code> : 属性的 value 值，读取属性时会返回该值，修改属性时，会对其进行修改\n<ol>\n<li>默认情况下这个值是 undefined</li>\n</ol>\n</li>\n<li><code>writable</code> : 表示是否可以修改属性的值\n<ol>\n<li>当我们直接在一个对象上定义某个属性时，这个属性的 [[Writable]] 为 true</li>\n<li>当我们通过属性描述符定义一个属性时，这个属性的 [[Writable]] 默认为 false</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p>存取 (访问器) 属性描述符</p>\n<ol>\n<li><code>configurable</code> : 属性是否可以通过 delete 删除属性，是否可以修改它的特性，或者是否可以将它修改为存取属性描述符\n<ol>\n<li>当我们直接在一个对象上定义某个属性时，这个属性的 [Configurable] 为 true</li>\n<li>当我们通过属性描述符定义一个属性时，这个属性的 [Configurable] 默认为 false</li>\n</ol>\n</li>\n<li><code>enumerable</code> : 属性是否可以通过 for-in 或者 Object.keys () 返回该属性\n<ol>\n<li>当我们直接在一个对象上定义某个属性时，这个属性的 [[Enumerable]] 为 true</li>\n<li>当我们通过属性描述符定义一个属性时，这个属性的 [[Enumerable]] 默认为 false</li>\n</ol>\n</li>\n<li><code>get</code> : 获取属性时会执行的函数，默认值为 <code>undefined</code></li>\n<li><code>set</code> : 设置属性时会执行的函数，默认值为 undefined</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> object = &#123;<br>  <span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">&quot;德尔蓝卡&quot;</span>,<br>  <span class=\"hljs-attr\">age</span>:<span class=\"hljs-number\">12</span>,<br>  <span class=\"hljs-attr\">_address</span>:<span class=\"hljs-string\">&quot;北京市&quot;</span><br>&#125;<br><span class=\"hljs-comment\">// 存取属性描述符</span><br><span class=\"hljs-comment\">// 1、隐藏某一个私有属性不希望直接被外界使用和赋值</span><br><span class=\"hljs-comment\">// 2、截获某一个属性它访问和设置值的过程时，会使用存储属性描述符</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">defineProperty</span>(object,<span class=\"hljs-string\">&quot;address&quot;</span>,&#123;<br>  <span class=\"hljs-attr\">configurable</span>:<span class=\"hljs-literal\">true</span>,<br>  <span class=\"hljs-attr\">enumerable</span>:<span class=\"hljs-literal\">true</span>,<br>  <span class=\"hljs-attr\">get</span>:<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-title function_\">foo</span>();<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_address</span>;<br>  &#125;,<br>  <span class=\"hljs-attr\">set</span>:<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">value</span>) &#123;<br>    <span class=\"hljs-title function_\">bar</span>();<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_address</span> = value<br>  &#125;<br>&#125;)<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(object.<span class=\"hljs-property\">address</span>);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(object);<br>object.<span class=\"hljs-property\">address</span> = <span class=\"hljs-string\">&quot;上海市&quot;</span>;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(object);<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;获取一次属性&quot;</span>);<br>&#125;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">bar</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;设置一次属性值&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>configurable</th>\n<th>enumerable</th>\n<th>value</th>\n<th>writable</th>\n<th>get</th>\n<th>set</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>数据属性描述符</td>\n<td>可以</td>\n<td>可以</td>\n<td>可以</td>\n<td>可以</td>\n<td>不可以</td>\n<td>不可以</td>\n</tr>\n<tr>\n<td>存取属性描述符</td>\n<td>可以</td>\n<td>可以</td>\n<td>不可以</td>\n<td>不可以</td>\n<td>可以</td>\n<td>可以</td>\n</tr>\n</tbody>\n</table>\n</li>\n</ol>\n</li>\n<li>\n<p>获取对象的属性描述符</p>\n<ol>\n<li><code>getOwnPropertyDescriptor</code> : 获取某一个特定属性的属性描述符</li>\n<li><code>getOwnPropertyDescriptors</code> : 获取所有属性的属性描述符</li>\n</ol>\n</li>\n<li>\n<p>访问器属性使用</p>\n</li>\n<li>\n<p>对象属性判断</p>\n</li>\n</ol>\n</li>\n<li>\n<p>对象的拷贝</p>\n<ol>\n<li>对象的引用赋值</li>\n<li>对象的浅拷贝</li>\n<li>对象的深拷贝</li>\n</ol>\n</li>\n<li>\n<p>ES6 对象增强</p>\n<ol>\n<li><code>Object.is()</code></li>\n<li>简写属性名</li>\n<li>可计算属性名称</li>\n<li>简写方法名</li>\n<li>对象解构\n<ol>\n<li>嵌套解构</li>\n<li>部分解构</li>\n<li>参数上下文匹配</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"2面向对象编程\"><a class=\"markdownIt-Anchor\" href=\"#2面向对象编程\">#</a> 2. 面向对象编程</h3>\n<ol>\n<li>\n<p>理解面向对象</p>\n<ol>\n<li>什么是面向对象编程</li>\n<li>面向对象编程的特性\n<ol>\n<li>封装</li>\n<li>继承</li>\n<li>多态</li>\n</ol>\n</li>\n<li>类和对象的关系</li>\n</ol>\n</li>\n<li>\n<p>创建对象方式</p>\n<ol>\n<li>工厂模式创建\n<ol>\n<li>该模式可以减少代码的重复量，缺点是无法获取对象的真实类型，获取对象类型都是 <code>object</code></li>\n</ol>\n</li>\n<li>构造函数创建\n<ol>\n<li>构造函数也称之为构造器 (constructor), 通常是我们在创建对象时会调用的函数</li>\n<li>一个普通的函数被使用 new 操作符来调用了，那么这个函数就称之为是一个构造函数</li>\n<li><code>new</code>\n<ol>\n<li>在函数内存中创建一个新的对象（空对象）</li>\n<li>这个对象内部的 [[prototype]] 属性会被赋值为该构造函数的 prototype 属性</li>\n<li>构造函数内部的 this，会指向创建出来的新对象</li>\n<li>执行函数的内部代码（函数体代码）</li>\n<li>如果构造函数没有返回非空对象，则返回创建出来的新对象</li>\n</ol>\n</li>\n<li>缺点：构造函数的缺点，需要为每一个对象的函数去创建一个函数对象实例，重复的创建对象</li>\n</ol>\n</li>\n<li>原型创建模式\n<ol>\n<li>认识原型</li>\n<li>对象的原型（隐式原型）\n<ol>\n<li>JavaScript 当中每个对象都有一个特殊的内置属性 [[prototype]]，这个特殊的对象可以指向另外一个对象</li>\n<li>原型对象的作用\n<ol>\n<li>当我们通过引用对象的属性 key 来获取一个 value 时，它会触发 [[Get]] 的操作</li>\n<li>这个操作会首先检查该属性是否有对应的属性，如果有的话就使用它</li>\n<li>如果对象中没有该属性，那么会访问对象 [[prototype]] 内置属性指向的对象上的属性</li>\n</ol>\n</li>\n<li>获取原型的方式\n<ol>\n<li>通过对象的__proto__属性可以获取到（但是这个是早期浏览器自己添加的，存在一定的兼容性问题）</li>\n<li>通过 Object.getPrototypeOf 方法可以获取到</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>函数的原型（显示原型）\n<ol>\n<li>所有的函数都有一个 prototype 的属性</li>\n<li></li>\n</ol>\n</li>\n<li><code>prototype属性</code>\n<ol>\n<li>指向对象的显式原型</li>\n</ol>\n</li>\n<li><code>constructor属性</code>\n<ol>\n<li>原型对象的属性：返回构造函数</li>\n</ol>\n</li>\n<li><code>__proto__属性</code>\n<ol>\n<li>指向对象的隐式原型</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p>面向对象继承</p>\n<ol>\n<li>\n<p>认识原型链</p>\n<ol>\n<li>深入原型对象\n<ol>\n<li><code>Object</code>  是顶层对象， <code>Object的原型对象上面没有原型对象而是null</code></li>\n<li><code>object</code>  是所有类的父类</li>\n</ol>\n</li>\n<li>简洁的原型语法</li>\n<li>修改原型的属性\n<ol>\n<li>需要在原型上添加过多的属性，通常我们会重新整个原型对象</li>\n<li>每创建一个函数，就会同时创建它的 prototype 对象，这个对象也会自动获取 constructor 属性</li>\n<li>这里给 prototype 重新赋值了一个对象，那么这个新对象的 constructor 属性，会指向 Object 构造函数，而不是 Person 构造函数了</li>\n<li>默认情况下原生的 constructor 属性是不可枚举</li>\n<li>如果希望解决这个问题，就可以使用我们前面介绍的 Object.defineProperty () 函数了</li>\n</ol>\n</li>\n<li>深入理解原型链\n<ol>\n<li>可以使用原型链继承</li>\n<li>原型链最顶层的原型对象就是 <code>Object</code>  的原型对象</li>\n</ol>\n</li>\n<li>原型和实例的关系\n<ol>\n<li>实例的属性 <code>__proto__</code> 指向原型对象</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p>继承的实现</p>\n<ol>\n<li>\n<p>原型链实现继承</p>\n<ol>\n<li>实现方式： <code>子类.prototype = new 父类();</code></li>\n<li>原型链实现继承的弊端\n<ol>\n<li>通过直接打印对象是看不到继承的属性</li>\n<li>这个属性会被多个对象共享，如果这个属性是一个引用类型，，其中一个共享对象进行修改时，那么就会造成问题，若是基本数据类型则不会出现该问题</li>\n<li>不能给 Person 传递参数，因为这个对象是一次性创建的</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p>借用构造函数实现继承 (经典继承)</p>\n<ol>\n<li>\n<p><code>constructor stealing</code> : 称之为借用构造函数、经典继承、伪造对象</p>\n</li>\n<li>\n<p>因为函数可以在任意的时刻被调用，因此通过 apply () 和 call () 方法也可以在新创建的对象上执行构造函数</p>\n</li>\n<li>\n<p>实现方式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 子类:私有属性和方法定义</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Student</span>(<span class=\"hljs-params\">name,age,friends,son</span>) &#123;<br>  <span class=\"hljs-comment\">// this指的是通过new绑定创建的stu对象</span><br>  <span class=\"hljs-title class_\">Person</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-variable language_\">this</span>,name,age,friends);<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">sno</span> = son;<br>&#125;<br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p>借用构造函数继承存在的弊端</p>\n<ol>\n<li>父类 Person 函数至少被调用了两次</li>\n<li>stu 原型对象上多出一些属性，而这些属性出现重复，因为子类本身就已经存在，但是这些属性没有存在的必要</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p>组合借用继承方式（<strong>和借用继承没有不同</strong>）</p>\n<ol>\n<li>实现方式</li>\n<li>存在弊端\n<ol>\n<li>一般都会调用两次父类构造函数，一次在创建子类原型的时候，一次在子类构造函数内部 (也就是每次创建子类实例的时候)</li>\n<li>所有的子类实例事实上会拥有两份父类的属性，一份在当前的实例自己里面 (也就是 person 本身的)，另一份在子类对应的原型对象中 (也就是 person.__proto__里面), 无需担心访问出现问题，默认一定是访问实例本身的属性</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p>寄生式继承函数</p>\n<ol>\n<li>实现方式</li>\n<li>存在弊端</li>\n</ol>\n</li>\n<li>\n<p>集成式组合继承</p>\n<ol>\n<li>释放方式</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p>ES6 类的使用</p>\n<ol>\n<li>class 类的定义\n<ol>\n<li>声明式、表达式两种</li>\n<li>构造方法</li>\n<li>属性定义</li>\n<li>方法定义</li>\n</ol>\n</li>\n<li>类的实例化过程\n<ol>\n<li>类的构建过程解析</li>\n<li>类的类型、function 类型</li>\n</ol>\n</li>\n<li>属性分类解析\n<ol>\n<li>实例属性和方法</li>\n<li>原型属性和访问器</li>\n<li>static 类方法和属性</li>\n</ol>\n</li>\n<li>class 类的继承\n<ol>\n<li>extends 关键字</li>\n<li>super 函数的使用\n<ol>\n<li>构造函数</li>\n<li>普通函数</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>Babel 的处理\n<ol>\n<li>Babel 工具对 class 的处理\n<ol>\n<li>阅读 Babel 转换后的代码</li>\n</ol>\n</li>\n<li>Babel 对继承的转换处理\n<ol>\n<li>Babel 继承的源码阅读</li>\n<li>_inherits</li>\n<li>_possibleConstructorReturn</li>\n<li>_classCallCheck</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p>面向对象面试题</p>\n</li>\n</ol>\n<h2 id=\"5es6~12新特性\"><a class=\"markdownIt-Anchor\" href=\"#5es6~12新特性\">#</a> 5.ES6~12 新特性</h2>\n<h3 id=\"1es6常见新特性\"><a class=\"markdownIt-Anchor\" href=\"#1es6常见新特性\">#</a> 1.ES6 常见新特性</h3>\n<ol>\n<li>基础补充\n<ol>\n<li>对象增强写法</li>\n<li>数组 / 对象解构</li>\n<li>var 与 let/const 区别</li>\n<li>作用域提升</li>\n<li>不允许重复声明变量</li>\n<li>window 对象的区别，let/const 不会添加到 window 对象上，<strong>保存的位置与之前也会有一定的区别</strong></li>\n<li></li>\n</ol>\n</li>\n</ol>\n<h3 id=\"2es7常见新特性\"><a class=\"markdownIt-Anchor\" href=\"#2es7常见新特性\">#</a> 2.ES7 常见新特性</h3>\n<h3 id=\"3es8常见新特性\"><a class=\"markdownIt-Anchor\" href=\"#3es8常见新特性\">#</a> 3.ES8 常见新特性</h3>\n<h3 id=\"4es9常见新特性\"><a class=\"markdownIt-Anchor\" href=\"#4es9常见新特性\">#</a> 4.ES9 常见新特性</h3>\n<h3 id=\"5es10常见新特性\"><a class=\"markdownIt-Anchor\" href=\"#5es10常见新特性\">#</a> 5.ES10 常见新特性</h3>\n<h3 id=\"6es11常见新特性\"><a class=\"markdownIt-Anchor\" href=\"#6es11常见新特性\">#</a> 6.ES11 常见新特性</h3>\n<h3 id=\"7es12常见新特性\"><a class=\"markdownIt-Anchor\" href=\"#7es12常见新特性\">#</a> 7.ES12 常见新特性</h3>\n<h2 id=\"6proxy-reflect\"><a class=\"markdownIt-Anchor\" href=\"#6proxy-reflect\">#</a> 6.Proxy-Reflect</h2>\n<h3 id=\"1proxy\"><a class=\"markdownIt-Anchor\" href=\"#1proxy\">#</a> 1.Proxy</h3>\n<ol>\n<li>在 ES6 中，新增了一个 Proxy 类，这个类从名字就可以看出来，是用于帮助我们创建一个代理</li>\n<li>如果我们希望监听一个对象的相关操作，那么我们可以先创建一个代理对象（Proxy 对象）</li>\n<li>之后对该对象的所有操作，都通过代理对象来完成，代理对象可以监听我们想要对原对象进行哪些操作</li>\n</ol>\n<h3 id=\"2reflect\"><a class=\"markdownIt-Anchor\" href=\"#2reflect\">#</a> 2.Reflect</h3>\n<ol>\n<li>Reflect 也是 ES6 新增的一个 API，它是一个对象，字面的意思是反射</li>\n<li>它主要提供了很多操作 JavaScript 对象的方法，有点像 Object 中操作对象的方法</li>\n<li></li>\n</ol>\n<h2 id=\"7异步处理\"><a class=\"markdownIt-Anchor\" href=\"#7异步处理\">#</a> 7. 异步处理</h2>\n<h3 id=\"1迭代器和生成器\"><a class=\"markdownIt-Anchor\" href=\"#1迭代器和生成器\">#</a> 1. 迭代器和生成器</h3>\n<ol>\n<li>\n<p>迭代器</p>\n<ol>\n<li>本身为一个对象，使用户在容器对象上遍访的对象，使用该接口无需关心对象的内部实现细节，<strong>迭代器是帮助我们对某个数据结构进行遍历的对象</strong></li>\n<li>在 JavaScript 中，<strong>迭代器也是一个具体的对象，这个对象需要符合迭代器协议 (iterator protocol)</strong>, 迭代器协议定义了产生一系列值 (无论是有限还是无限个) 的标准方式，那么在 js 中这个标准就是一个<strong>特定的 next 方法</strong></li>\n<li>next 方法有如下的要求\n<ol>\n<li>一个无参数函数或者含有一个参数的函数，返回一个应当拥有以下两个属性的对象\n<ol>\n<li>done（boolean）\n<ol>\n<li>如果迭代器可以产生序列中的下一个值，则为 false，这等价于没有指定 done 这个属性</li>\n<li>如果迭代器已将序列迭代完毕，则为 true。这种情况下，value 是可选的，如果它依然存在，即为迭代结束之后的默认返回值</li>\n</ol>\n</li>\n<li>value\n<ol>\n<li>迭代器返回的任何 JavaScript 值，done 为 true 时可省略</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p>可迭代对象</p>\n<ol>\n<li>\n<p>当一个对象实现了 ** <code>iterable protocol</code> ** 协议时，它就是一个可迭代对象</p>\n</li>\n<li>\n<p>这个对象要求是必须实现 <code>@@iterator方法</code> ，即 ** <code>[Symbol.iterator]属性对应着一个函数</code>  ** 在代码中我们使用 <code>Symbol.iterator</code>  访问该属性</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//可迭代对象iteratorObj</span><br><span class=\"hljs-keyword\">const</span> iteratorObj = &#123;<br>  <span class=\"hljs-attr\">array</span>: [<span class=\"hljs-number\">111</span>, <span class=\"hljs-number\">222</span>, <span class=\"hljs-number\">333</span>],<br>  [<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>]: <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> index = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">return</span> &#123;<br>      <span class=\"hljs-comment\">// 返回一个迭代器</span><br>      <span class=\"hljs-attr\">next</span>:<span class=\"hljs-function\">() =&gt;</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> (index &lt; <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">array</span>.<span class=\"hljs-property\">length</span>) &#123;<br>          <span class=\"hljs-keyword\">return</span> &#123; <span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">false</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">array</span>[index++] &#125;<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>          <span class=\"hljs-keyword\">return</span> &#123; <span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-literal\">undefined</span> &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(iteratorObj[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>]);<br><span class=\"hljs-comment\">// 调用该方法会生成一个可迭代对象</span><br><span class=\"hljs-keyword\">const</span> iterator = iteratorObj[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>]();<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(iterator);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(iterator.<span class=\"hljs-title function_\">next</span>());<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(iterator.<span class=\"hljs-title function_\">next</span>());<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(iterator.<span class=\"hljs-title function_\">next</span>());<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(iterator.<span class=\"hljs-title function_\">next</span>());<br><span class=\"hljs-comment\">// 返回一个新的可迭代对象</span><br><span class=\"hljs-keyword\">const</span> iterator2 = iteratorObj[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>]();<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(iterator2);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(iterator2.<span class=\"hljs-title function_\">next</span>());<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(iterator2.<span class=\"hljs-title function_\">next</span>());<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(iterator2.<span class=\"hljs-title function_\">next</span>());<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(iterator2.<span class=\"hljs-title function_\">next</span>());<br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p>原生迭代器对象，已经实现可迭代协议有： <code>String、Array、Map、Set、arguments对象、NodeList集合</code></p>\n</li>\n<li>\n<p>可迭代对象的应用</p>\n<ol>\n<li>JavaScript 语法： <code>for...of</code> 、 <code>展开语法(spread syntax)</code> 、 <code>yield*</code> 、 <code>解构赋值</code></li>\n<li>创建一些对象时： <code>new Map</code> 、 <code>new WeakMap</code> 、 <code>new Set</code> 、 <code>new WeakSet</code></li>\n<li>一些方法调用： <code>Promise.all(iterator)</code> 、 <code>Promise.race(iterator)</code> 、 <code>Array.from(iterator)</code></li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p>生成器</p>\n<ol>\n<li>生成器是 ES6 中新增的一种函数控制、使用的方案，它可以让我们更加灵活的控制函数什么时候继续执行、暂停执行等</li>\n<li>生成器函数也是一个函数，但是和普通的函数有一些区别\n<ol>\n<li>生成器函数需要<strong>在 function 的后面加一个符号 <code>*</code> </strong></li>\n<li>生成器函数可以通过 ** <code>yield关键字</code>  ** 来控制函数的执行流程</li>\n<li>生成器函数的<strong>返回值是一个 Generator</strong>（生成器）</li>\n<li>生成器事实上是一种<strong>特殊的迭代器</strong>，MDN：Instead,they return a special type of iterator,called aGenerator</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"2promise的使用\"><a class=\"markdownIt-Anchor\" href=\"#2promise的使用\">#</a> 2.Promise 的使用</h3>\n<ol>\n<li>\n<p><code>Promise</code>  是一个类，可以翻译为承诺、许诺、期约</p>\n</li>\n<li>\n<p><code>then</code>  是一个 Promise 对象上的一个方法：实际上是 Promise 原型上的 <code>Promise.prototype.then()</code></p>\n</li>\n<li>\n<p>浏览器的循环事件</p>\n<ol>\n<li>\n<p>进程与线程理解</p>\n<ol>\n<li>进程：计算已经运行的程序，是操作系统管理程序的一种方式，启动一个应用程序，就会默认启动一个进程 (也可能是多个进程)</li>\n<li>线程：操作系统能够运行运算调度的最小单位，通常情况下它被包含在进程中，启动每一个进程中，都会启动至少一个线程用来执行程序中的代码，这个线程被称为主线程</li>\n</ol>\n</li>\n<li>\n<p>浏览器中的 JavaScript 线程</p>\n<ol>\n<li>JavaScript 是单线程，拥有自己的容器进程：浏览器或 node</li>\n<li>浏览器是多进程的，当我们打开一个 tab 页面时就会开启一个新的进程，这是为了防止一个页面卡死而造成所有页面无法响应，整个浏览器需要强制退出</li>\n<li>JavaScript 同一时刻只能做一件事情，如果该事情非常耗时，那么当前的线程就会被阻塞，然而浏览器每一个进程是多线程的，那么其他的线程可以来完成这个耗时的操作，如：网络请求、定时器等，我们只需要在特定的时刻执行回调即可</li>\n</ol>\n</li>\n<li>\n<p>事件循环图解</p>\n<p><img src=\"../../all_photo/image-20220725112224437.png\" alt=\"image-20220725112224437\"></p>\n</li>\n<li>\n<p>微任务和宏任务</p>\n<ol>\n<li>微任务队列 (microtask queue)：一般有 queueMicrotask ()、Promise 的 then 回调、MutationObserver 的 API: 监听 DOM 的调用</li>\n<li>宏任务队列 (macrotask queue)：一般有定时器、ajax、DOM 事件点击、UI Rendering 渲染</li>\n<li>规范：在执行任何的宏任务之前，都需要先保证微任务队列已经被清空</li>\n</ol>\n</li>\n<li>\n<p>事件循环对于两个队列的优先级</p>\n<ol>\n<li><code>main script</code>  代码优先执行</li>\n<li>在执行任何一个宏任务之前 (不是队列，而是一个宏任务)，都会先查看微任务队列中是否有任务需要执行，也就是说宏任务执行之前，必须保证微任务对队列是空的，若果不为空，那么就优先执行微任务队列中的任务 (回调函数)</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p>node 的事件循环</p>\n<ol>\n<li>浏览器中 <code>EventLoop即事件循环</code> 是根据 HTML5 定义的规范来实现的，不同的浏览器可能会有不同的实现，而 node 中是由 <code>libuv库</code> 现实的</li>\n<li>微任务和宏任务\n<ol>\n<li>宏任务 (macrotask)：setTimeout、setInterval、IO 事件、setImmediate、close 事件</li>\n<li>微任务 (microtask)：Promise 的 then 回调、process.nextTick、queueMicrotask</li>\n<li>node 队列执行顺序\n<ol>\n<li><code>next tick microtask queue</code></li>\n<li><code>other microtask queue</code></li>\n<li><code>timer queue</code></li>\n<li><code>poll queue</code></li>\n<li><code>check queue</code></li>\n<li><code>close queue</code></li>\n</ol>\n</li>\n<li></li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"3async和await\"><a class=\"markdownIt-Anchor\" href=\"#3async和await\">#</a> 3.async 和 await</h3>\n<ol>\n<li><code>async</code>  关键字用于声明一个异步函数</li>\n<li><code>async</code>  是 <code>asynchronous</code>  单词的缩写，意思为异步、非同步</li>\n<li><code>sync</code>  是 <code>synchronous</code>  单词的缩写，意思为同步、同时</li>\n</ol>\n<h2 id=\"8模块化与包管理工具\"><a class=\"markdownIt-Anchor\" href=\"#8模块化与包管理工具\">#</a> 8. 模块化与包管理工具</h2>\n<ol>\n<li>模块化开发\n<ol>\n<li>认识模块化开发\n<ol>\n<li>事实上模块化开发最终的目的是将程序划分成一个个小的结构，这个结构中编写属于自己的逻辑代码，有自己的作用域，不会影响到其他的结构，这个结构可以将自己希望暴露的变量、函数、对象等导出给其结构使用，也可以通过某种方式，导入另外结构中的变量、函数、对象</li>\n</ol>\n</li>\n<li><code>commonJS规范</code>\n<ol>\n<li><code>CommonJS和Node关系</code>\n<ol>\n<li>CommonJS 是一个规范，最初是在浏览器以外的地方使用，当时被命名为<strong> ServerJS</strong>，后来为了体现它的广泛性，修改为<strong> CommonJS</strong>，平时我们也会简称为<strong> CJS</strong></li>\n<li>Node 是 CommonJS 在服务器端一个具有代表性的实现，Browserify 是 CommonJS 在浏览器中的一种实现，webpack 打包工具具备对 CommonJS 的支持和转换，Node 中对 CommonJS 进行了支持和实现，让我们在开发 node 的过程中可以方便的进行模块化开发，在 Node 中每一个 js 文件都是一个单独的模块，这个模块中包括 CommonJS 规范的核心变量：exports、module.exports、require，我们可以使用这些变量来方便的进行模块化开发，前面我们提到过模块化的核心是导出和导入，Node 中对其进行了实现：exports 和 module.exports 可以负责对模块中的内容进行导出，require 函数可以帮助我们导入其他模块（自定义模块、系统模块、第三方库模块）中的内容</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><code>AMD和CMD规范</code></li>\n<li><code>ESModule规范化</code></li>\n<li><code>ES Module和CommonJS</code></li>\n</ol>\n</li>\n<li>npm 包管理工具</li>\n</ol>\n",
            "tags": [
                "JavaScript"
            ]
        }
    ]
}