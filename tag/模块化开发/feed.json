{
    "version": "https://jsonfeed.org/version/1",
    "title": "XGG • All posts by \"模块化开发\" tag",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2023/03/05/12001_%E6%A8%A1%E5%9D%97%E5%8C%96/",
            "url": "http://example.com/2023/03/05/12001_%E6%A8%A1%E5%9D%97%E5%8C%96/",
            "title": "模块化开发",
            "date_published": "2023-03-05T07:09:43.000Z",
            "content_html": "<p>🌸  <span style=\"font-size:bold;color:purple\">您好，欢迎您的阅读，等君久矣，愿与君畅谈.</span><br>\n🔭  <span style=\"font-size:bold;color:purple\">§ 始于颜值 § 陷于才华 § 忠于人品 §</span><br>\n📫  <span style=\"font-size:initial;color:purple\">希望我们可以进一步交流，共同学习，共同探索未知的技术世界 <a href=\"https://juejin.cn/user/2784392994882045\">稀土掘金</a> OR <a href=\"https://github.com/LuckyWishes\">GitHub</a>.</span></p>\n<hr />\n<p>前期出现全局污染和依赖管理混乱等问题，可以使用匿名函数自执行方式形成独立块级作用域解决，目前可以使用模块化方案解决此类问题</p>\n<h4 id=\"commonjs\"><a class=\"markdownIt-Anchor\" href=\"#commonjs\">#</a> Common.js</h4>\n<h6 id=\"场景\"><a class=\"markdownIt-Anchor\" href=\"#场景\">#</a> 场景</h6>\n<ul>\n<li>Node 使用 Common.js 在服务器端实现模块化</li>\n<li>Browserify 使用 Common.js 在浏览器实现</li>\n<li>webpack 打包工具对 Common.js 的支持和转换</li>\n</ul>\n<h6 id=\"使用和原理\"><a class=\"markdownIt-Anchor\" href=\"#使用和原理\">#</a> 使用和原理</h6>\n<ul>\n<li>规范：\n<ul>\n<li>每一个 js 文件是单独的模块 (module)</li>\n<li>包含 exports、module.exports、require</li>\n<li>exports 和 module.exports 对模块内容进行导出，require 函数导入其他模块 (自定义模块、系统模块、第三方库模块)</li>\n<li>module：记录当前模块信息、require：引入模块的方法、exports：当前模块导出的属性</li>\n</ul>\n</li>\n<li>在编译过程中，common.js 对 js 代码进行包装，形成一个包装函数，我们编写的代码作为包装函数的执行上下文，使用的 require、exports、module 本质上是通过形参的方式传递到包装函数中</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">exports</span>,<span class=\"hljs-built_in\">require</span>,<span class=\"hljs-variable language_\">module</span>,__filename,__dirname</span>)&#123;<br>    <span class=\"hljs-keyword\">const</span> sayName = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;./hello.js&#x27;</span>)<br>    <span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">say</span>(<span class=\"hljs-params\"></span>)&#123;<br>        <span class=\"hljs-keyword\">return</span> &#123;<br>            <span class=\"hljs-attr\">name</span>:<span class=\"hljs-title function_\">sayName</span>(),<br>            <span class=\"hljs-attr\">author</span>:<span class=\"hljs-string\">&#x27;我不是外星人&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>\n<ul>\n<li>在模块加载过程中，通过 <code>runInThisContext(可以理解为eval)</code>  执行 <code>modulefunction</code></li>\n</ul>\n<h6 id=\"require文件加载流程\"><a class=\"markdownIt-Anchor\" href=\"#require文件加载流程\">#</a> require 文件加载流程</h6>\n<ul>\n<li>接收的唯一参数作为一个标识符，Commonjs 下对不同的标识符处理流程不同，但都是找到对应的模块</li>\n<li>加载文件原则 (nodejs)\n<ul>\n<li><code>fs</code> 、 <code>http</code> 、 <code>path</code>  等标识符，会被作为 nodejs 的 <code>核心模块</code> ，核心模块的优先级仅次于缓存加载，在 Node 源码编译中，已被编译成二进制代码，所以加载核心模块速度最快</li>\n<li><code>./</code>  和 <code>../</code>  作为相对路径的 <code>文件模块</code> ， <code>/</code>  作为绝对路径的 <code>文件模块</code> ， <code>require()</code>  方法会将路径转换成真实路径，并以真实路径作为索引，将编译后的结果缓存起来，第二次加载的时候会更快</li>\n<li>非路径形式也非核心模块的模块，将作为 <code>自定义模块</code> ，查找会遵循原则：首先在当前目录下的 <code>node_modules</code>  目录查找，若没有在父级目录的 <code>node_modules</code>  查找，若没有在父级目录的父级目录的 <code>node_modules</code>  中查找，沿着路径向上递归，直到根目录下的 <code>node_modules</code>  目录，在查找过程中，会找 <code>package.json</code>  中 <code>main</code>  属性指向的文件，若没有 <code>package.json</code> , 在 node 环境下会依次查找 <code>index.js</code> 、 <code>index.json</code> 、 <code>index.node</code></li>\n</ul>\n</li>\n</ul>\n<h6 id=\"require模块引入与处理\"><a class=\"markdownIt-Anchor\" href=\"#require模块引入与处理\">#</a> require 模块引入与处理</h6>\n<ul>\n<li>CommonJS 模块同步加载并执行模块文件，在执行阶段分析模块依赖，采用 <code>深度优先遍历</code> ，执行顺序是父 -&gt; 子 -&gt; 父</li>\n<li>require 加载原理\n<ul>\n<li>module：在 Node 中每一个 js 文件都是一个 <code>module</code> , <code>module</code>  上保存了 <code>exports</code>  等信息之外，还有一个 <code>loaded</code>  表示该模块是否被加载，值为 <code>false</code>  表示还没有加载，值为 <code>true</code>  表示已经加载</li>\n<li>Module：如 nodejs，整个系统运行之后，会用 <code> Module</code>  缓存每一个模块加载的信息</li>\n<li>源码理解：1. <code>require</code>  会接收一个参数 —— 文件标识符，然后分析查找定位文件，分析过程我们上述已经讲到了，加下来会从 <code>Module</code>  上查找有没有缓存，如果有缓存，那么直接返回缓存的内容。如果没有缓存，会创建一个 <code>module</code>  对象，缓存到 <code>Module</code>  上，然后执行文件，加载完文件，将 <code>loaded</code>  属性设置为 <code>true </code> , 然后返回 <code>module.exports</code>  对象，完成模块加载流程。模块导出就是 <code>return</code>  这个变量的其实跟 a = b 赋值一样， 基本类型导出的是值， 引用类型导出的是引用地址。 <code>exports</code>  和 <code>module.exports</code>  持有相同引用，因为最后导出的是 <code>module.exports</code> , 所以对 <code>exports</code>  进行赋值会导致 <code>exports</code>  操作的不再是 <code>module.exports</code>  的引用。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// id 为路径标识符</span><br> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">require</span>(<span class=\"hljs-params\">id</span>) &#123;<br> <span class=\"hljs-comment\">/* 查找  Module 上有没有已经加载的 js  对象*/</span><br>     <span class=\"hljs-keyword\">const</span>  cachedModule = <span class=\"hljs-title class_\">Module</span>.<span class=\"hljs-property\">_cache</span>[id]<br> <br> <span class=\"hljs-comment\">/* 如果已经加载了那么直接取走缓存的 exports 对象  */</span><br> <span class=\"hljs-keyword\">if</span>(cachedModule)&#123;<br>     <span class=\"hljs-keyword\">return</span> cachedModule.<span class=\"hljs-property\">exports</span><br> &#125;<br> <br> <span class=\"hljs-comment\">/* 创建当前模块的 module  */</span><br> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable language_\">module</span> = &#123; <span class=\"hljs-attr\">exports</span>: &#123;&#125; ,<span class=\"hljs-attr\">loaded</span>: <span class=\"hljs-literal\">false</span> , ...&#125;<br><br> <span class=\"hljs-comment\">/* 将 module 缓存到  Module 的缓存属性中，路径标识符作为 id */</span>  <br> <span class=\"hljs-title class_\">Module</span>.<span class=\"hljs-property\">_cache</span>[id] = <span class=\"hljs-variable language_\">module</span><br> <span class=\"hljs-comment\">/* 加载文件 */</span><br> <span class=\"hljs-title function_\">runInThisContext</span>(<span class=\"hljs-title function_\">wrapper</span>(<span class=\"hljs-string\">&#x27;module.exports = &quot;123&quot;&#x27;</span>))(<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span>, <span class=\"hljs-built_in\">require</span>, <span class=\"hljs-variable language_\">module</span>, __filename, __dirname)<br> <span class=\"hljs-comment\">/* 加载完成 */</span>/<br> <span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">loaded</span> = <span class=\"hljs-literal\">true</span> <br> <span class=\"hljs-comment\">/* 返回值 */</span><br> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span><br> &#125;<br></code></pre></td></tr></table></figure>\n</li>\n<li>require 解决重复加载：首先加载之后的文件的 module 会被缓存到 Module 上，比如一个模块已经 require 引入了 a 模块，如果另外一个模块再次引用 a ，那么会直接读取缓存值 module ，所以无需再次执行模块</li>\n<li>require 动态加载：require 可以在任意的上下文，动态加载模块。require 本质上就是一个函数，那么函数可以在任意上下文中执行，来自由地加载其他模块的属性方法。</li>\n</ul>\n<h6 id=\"exports和moduleexports\"><a class=\"markdownIt-Anchor\" href=\"#exports和moduleexports\">#</a> exports 和 module.exports</h6>\n<ul>\n<li>exports 就是传入到当前模块内的一个对象，本质上就是 module.exports</li>\n<li>为什么 exports={} 直接赋值一个对象就不可以呢？解释如下所示：假设 wrap 就是 Commonjs 规范下的包装函数，我们的 js 代码就是包装函数内部的内容。当我们把  myExports 对象传进去，但是直接赋值  myExports = { name:‘我不是外星人’} 没有任何作用，相等于内部重新声明一份 myExports 而和外界的 myExports 断绝了关系。所以解释了为什么不能 exports={…}  直接赋值。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">wrap</span> (myExports)&#123;<br>    myExports=&#123;<br>       <span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">&#x27;我不是外星人&#x27;</span><br>   &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> myExports = &#123;<br>    <span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">&#x27;alien&#x27;</span><br>&#125;<br><span class=\"hljs-title function_\">wrap</span>(myExports)<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(myExports)<br></code></pre></td></tr></table></figure>\n<ul>\n<li>module.exports：可以单独导出一个对象、函数、类。 exports 和 module.exports 持有相同引用，在一个文件中，我们最好选择 exports 和 module.exports 两者之一，如果两者同时存在，很可能会造成覆盖的情况发生。</li>\n<li>如果我们不想在 <code>common.js</code>  中导出对象，而是只导出一个类或者函数或者其他属性的情况，那么 module.exports 就更方便了，如上我们知道 exports 会被初始化成一个对象，也就是我们只能在对象上绑定属性，但是我们可以通过 module.exports 自定义导出对象外的其他类型元素。module.exports 当导出一些函数等非对象属性的时候，也有一些风险，就比如循环引用的情况下。对象会保留相同的内存地址，就算一些属性是后绑定的，也能间接通过异步形式访问到。但是如果 module.exports 为一个非对象其他属性类型，在循环引用的时候，就容易造成属性丢失的情况发生了。</li>\n</ul>\n<h4 id=\"es-module\"><a class=\"markdownIt-Anchor\" href=\"#es-module\">#</a> ES Module</h4>\n<h6 id=\"导出和导入\"><a class=\"markdownIt-Anchor\" href=\"#导出和导入\">#</a> 导出和导入</h6>\n<ul>\n<li>所有通过 export 导出的属性，在 import 中可以通过结构的方式，解构出来</li>\n<li>export 正常导出，import 导入，这种情况下 import {} 内部的变量名称，要与 export {} 完全匹配。</li>\n<li>默认导出 <code>export default</code> , 默认导出内容可以是函数、属性方法、对象。对于引入默认导出的模块，import anyName from ‘module’， anyName 可以是自定义名称。</li>\n<li>混合导入｜导出</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// a.js   2中导出方式： export default 和 export </span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> name = <span class=\"hljs-string\">&#x27;《React进阶实践指南》&#x27;</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> author = <span class=\"hljs-string\">&#x27;我不是外星人&#x27;</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span>  <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">say</span> ()&#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;hello , world&#x27;</span>)<br>&#125;<br><span class=\"hljs-comment\">// main.js   导入方式</span><br><span class=\"hljs-comment\">// 第一种</span><br><span class=\"hljs-keyword\">import</span> theSay , &#123; name, author <span class=\"hljs-keyword\">as</span>  bookAuthor &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./a.js&#x27;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<br>    theSay,     <span class=\"hljs-comment\">// ƒ say() &#123;console.log(&#x27;hello , world&#x27;) &#125;</span><br>    name,       <span class=\"hljs-comment\">// &quot;《React进阶实践指南》&quot;</span><br>    bookAuthor  <span class=\"hljs-comment\">// &quot;我不是外星人&quot;</span><br>)<br><span class=\"hljs-comment\">// 第二种</span><br><span class=\"hljs-comment\">// 导出的属性被合并到 mes 属性上， export 被导入到对应的属性上，export default 导出内容被绑定到 default 属性上。 theSay 也可以作为被 export default 导出属性。</span><br><span class=\"hljs-keyword\">import</span> theSay, * <span class=\"hljs-keyword\">as</span> mes <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./a&#x27;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<br>    theSay, <span class=\"hljs-comment\">// ƒ say() &#123; console.log(&#x27;hello , world&#x27;) &#125;</span><br>    mes <span class=\"hljs-comment\">// &#123; name:&#x27;《React进阶实践指南》&#x27; , author: &quot;我不是外星人&quot; ，default:  ƒ say() &#123; console.log(&#x27;hello , world&#x27;) &#125; &#125;</span><br>)<br></code></pre></td></tr></table></figure>\n<ul>\n<li>重命名导入： <code>import &#123;  name as bookName , say,  author as bookAuthor  &#125; from 'module'</code></li>\n<li>重定向导出</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 第一种方式：重定向导出 module 中的所有导出属性， 但是不包括 module 内的 default 属性。</span><br><span class=\"hljs-comment\">// 第二种方式：从 module 中导入 name ，author ，say 再以相同的属性名，导出。</span><br><span class=\"hljs-comment\">// 第三种方式：从 module 中导入 name ，重属名为 bookName 导出，从 module 中导入author ，重属名为 bookAuthor 导出，正常导出 say 。</span><br><span class=\"hljs-keyword\">export</span> * <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;module&#x27;</span> <span class=\"hljs-comment\">// 第一种方式</span><br><span class=\"hljs-keyword\">export</span> &#123; name, author, ..., say &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;module&#x27;</span> <span class=\"hljs-comment\">// 第二种方式</span><br><span class=\"hljs-keyword\">export</span> &#123; name <span class=\"hljs-keyword\">as</span> bookName ,  author <span class=\"hljs-keyword\">as</span> bookAuthor , ..., say &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;module&#x27;</span> <span class=\"hljs-comment\">//第三种方式</span><br></code></pre></td></tr></table></figure>\n<ul>\n<li>无需导入模块，只运行模块。执行 module 不导出值 多次调用 module 只运行一次。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&#x27;module&#x27;</span> <br></code></pre></td></tr></table></figure>\n<ul>\n<li>动态导入。import (‘module’) ，动态导入返回一个 Promise。为了支持这种方式，需要在 webpack 中做相应的配置处理。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> promise = <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">&#x27;module&#x27;</span>)<br></code></pre></td></tr></table></figure>\n<h6 id=\"特性\"><a class=\"markdownIt-Anchor\" href=\"#特性\">#</a> 特性</h6>\n<ul>\n<li>静态导入导出的优势，实现了 <code>tree shaking</code> , 可以实现 <code>import()</code>  懒加载的方式实现代码分割。</li>\n<li>静态语法。引入和导出是静态的，import 会自动提升到代码的顶层。import、export 不能放在块级作用域或条件语句中。import 的导入名不能为字符串或在判断语句。</li>\n<li>执行特性。与 Common.js 不同的是 ，CommonJS 模块同步加载并执行模块文件，ES6 模块提前加载并执行模块文件，ES6 模块在预处理阶段分析模块依赖，在执行阶段执行模块，两个阶段都采用深度优先遍历，执行顺序是子 -&gt; 父。</li>\n<li>导出绑定\n<ul>\n<li>不能修改 import 导入的属性，若直接修改会报错。</li>\n<li>属性绑定。对于 import 属性如下总结\n<ul>\n<li>使用 import 被导入的模块运行在严格模式下。</li>\n<li>使用 import 被导入的变量是只读的，可以理解默认为 const 装饰，无法被赋值</li>\n<li>使用 import 被导入的变量是与原变量绑定 / 引用的，可以理解为 import 导入的变量无论是否为基本类型都是引用传递。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h6 id=\"import动态引入\"><a class=\"markdownIt-Anchor\" href=\"#import动态引入\">#</a> import () 动态引入</h6>\n<ul>\n<li>import () 返回一个 Promise 对象，返回的 Promise 的 then 成功回调中，可以获取模块的加载成功信息。import () 这种加载效果，可以很轻松的实现代码分割。避免一次性加载大量 js 文件，造成首次加载白屏时间过长的情况。</li>\n<li>动态加载。import () 动态加载一些内容，可以放在条件语句或者函数执行上下文中。</li>\n<li>懒加载。import () 可以实现懒加载。如路由懒加载等</li>\n<li>tree shaking 的实现</li>\n</ul>\n<h4 id=\"commonjs与es-module总结\"><a class=\"markdownIt-Anchor\" href=\"#commonjs与es-module总结\">#</a> Commonjs 与 es module 总结</h4>\n<ul>\n<li>Commonjs 的特性如下：\n<ul>\n<li>CommonJS 模块由 JS 运行时实现。</li>\n<li>CommonJs 是单个值导出，本质上导出的就是 exports 属性。</li>\n<li>CommonJS 是可以动态加载的，对每一个加载都存在缓存，可以有效的解决循环引用问题。</li>\n<li>CommonJS 模块同步加载并执行模块文件。</li>\n</ul>\n</li>\n<li>Es module 的特性如下：\n<ul>\n<li>ES6 Module 静态的，不能放在块级作用域内，代码发生在编译时。</li>\n<li>ES6 Module 的值是动态绑定的，可以通过导出方法修改，可以直接访问修改结果。</li>\n<li>ES6 Module 可以导出多个属性和方法，可以单个导入导出，混合导入导出。</li>\n<li>ES6 模块提前加载并执行模块文件，</li>\n<li>ES6 Module 导入模块在严格模式下。</li>\n<li>ES6 Module 的特性可以很容易实现 Tree Shaking 和 Code Splitting。</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "模块化开发"
            ]
        }
    ]
}