{
    "version": "https://jsonfeed.org/version/1",
    "title": "XGG • All posts by \"javascript基础\" category",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2022/06/15/4001_JavaScript/",
            "url": "http://example.com/2022/06/15/4001_JavaScript/",
            "title": "JavaScript",
            "date_published": "2022-06-15T11:12:03.000Z",
            "content_html": "<p>🌸  <span style=\"font-size:bold;color:purple\">您好，欢迎您的阅读，等君久矣，愿与君畅谈.</span><br>\n🔭  <span style=\"font-size:bold;color:purple\">§ 始于颜值 § 陷于才华 § 忠于人品 §</span><br>\n📫  <span style=\"font-size:initial;color:purple\">希望我们可以进一步交流，共同学习，共同探索未知的技术世界 <a href=\"https://juejin.cn/user/2784392994882045\">稀土掘金</a> OR <a href=\"https://github.com/LuckyWishes\">GitHub</a>.</span></p>\n<hr />\n<h5 id=\"函数的this绑定\"><a class=\"markdownIt-Anchor\" href=\"#函数的this绑定\">#</a> 函数的 this 绑定</h5>\n<ol>\n<li>\n<p>全局作用域下</p>\n<ol>\n<li>\n<p>浏览器环境：全局作用域下 <code>this</code>  绑定 window</p>\n</li>\n<li>\n<p>node 环境： <code>空对象&#123;&#125;</code></p>\n<ol>\n<li>执行步骤：首先将要执行的 js 文件作为模块，然后进行加载编译，此时将 js 代码所有文件放入一个函数中，执行该函数，但是该函数调用 <code>call()</code> , 在调用时向 <code>call()</code>  中传入一个空对象绑定为 <code>this</code>  即 <code>执行函数.call(&#123;&#125;)</code></li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p><em>函数作用域下</em> <code>this</code>  指向</p>\n<ol>\n<li>\n<p>函数在被调用时，JavaScript 会默认给 this 绑定一个值，this 指向与函数所处位置 (<strong>函数定义位置</strong>) 无关，与<strong>函数被调用的方式</strong>及调用位置有关，<strong>this 是在运行时被绑定</strong></p>\n</li>\n<li>\n<p><strong>默认绑定</strong></p>\n<ol>\n<li>\n<p>独立函数调用 <code>this</code>  指向的是全局对象 <code>window</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>);<br>&#125;<br><span class=\"hljs-keyword\">var</span> obj1 = &#123;<br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;obj1&quot;</span>,<br>  <span class=\"hljs-attr\">foo</span>: foo<br>&#125;<br><span class=\"hljs-comment\">// 将obj1的foo赋值给bar</span><br><span class=\"hljs-keyword\">var</span> bar = obj1.<span class=\"hljs-property\">foo</span>;<br><span class=\"hljs-title function_\">bar</span>();<br></code></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li>\n<p><strong>隐式绑定</strong></p>\n<ol>\n<li>\n<p>通过某个对象进行调用，即调用位置中是<strong>通过某个对象发起的函数调用</strong> (谁发起函数调用 this 就绑定谁)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>);<br>&#125;<br><span class=\"hljs-keyword\">var</span> test = &#123;<br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;test&quot;</span>,<br>  <span class=\"hljs-attr\">foo</span>: foo<br>&#125;<br><span class=\"hljs-keyword\">var</span> obj1 = &#123;<br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;obj1&quot;</span>,<br>  <span class=\"hljs-attr\">test</span>: test<br>&#125;<br><span class=\"hljs-keyword\">var</span> obj2 = &#123;<br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;obj2&quot;</span>,<br>  <span class=\"hljs-attr\">obj1</span>: obj1<br>&#125;<br>obj2.<span class=\"hljs-property\">obj1</span>.<span class=\"hljs-property\">test</span>.<span class=\"hljs-title function_\">foo</span>();<span class=\"hljs-comment\">//test对象</span><br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>object.fn()</code> ：object 对象会被 js 引擎绑定到 fn 函数中的 this 上</p>\n</li>\n<li>\n<p>隐式绑定的前提条件</p>\n<ol>\n<li>必须在调用的对象内部有一个对函数的引用（比如一个属性）</li>\n<li>如果没有这样的引用，在进行调用时，会报找不到该函数的错误</li>\n<li>正是通过这个引用，间接的将 this 绑定到了这个对象上</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p><strong>显示绑定</strong></p>\n<ol>\n<li>\n<p><code>call()</code></p>\n<ol>\n<li>第一个参数为绑定对象，第二个参数为参数列表 (剩余参数形式)</li>\n</ol>\n</li>\n<li>\n<p><code>apply()</code></p>\n<ol>\n<li>第一个参数为绑定对象，第二个参数为参数列表 (数组形式)</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-params\">num1,num2,num3</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(num1+num2+num3,<span class=\"hljs-variable language_\">this</span>);<br>&#125;<br>sum.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-string\">&quot;call&quot;</span>,<span class=\"hljs-number\">20</span>,<span class=\"hljs-number\">30</span>,<span class=\"hljs-number\">40</span>);<span class=\"hljs-comment\">//剩余参数形式</span><br>sum.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-string\">&quot;apply&quot;</span>,[<span class=\"hljs-number\">20</span>,<span class=\"hljs-number\">30</span>,<span class=\"hljs-number\">40</span>]);<span class=\"hljs-comment\">//数组形式</span><br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>bind()</code></p>\n<ol>\n<li>第一个参数为绑定对象，第二个参数为参数列表 (剩余参数形式), <code>bind</code>  返回为一个新的函数</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>);<br>&#125;<br><span class=\"hljs-comment\">// 默认绑定和显示绑定bind冲突：优先级（显示绑定）</span><br><span class=\"hljs-keyword\">var</span> newFoo = foo.<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-string\">&quot;aaaa&quot;</span>);<br><span class=\"hljs-title function_\">newFoo</span>();<br></code></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li>\n<p><strong>new 绑定</strong></p>\n<ol>\n<li>使用 new 关键字来调用函数执行如下的操作\n<ol>\n<li>创建一个全新的对象，<strong>并将该对象赋值给 this，函数最后返回该对象</strong></li>\n<li>这个新对象会被执行 prototype 连接</li>\n<li>这个新对象会绑定到函数调用的 this 上（this 的绑定在这个步骤完成）</li>\n<li>如果函数没有返回其他对象，表达式会返回这个新对象</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p><strong>内置函数绑定</strong></p>\n<ol>\n<li>\n<p><code>setTimeout</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 因为setTimeout内部实现函数调用时为独立函数调用，所以打印this时指向window</span><br><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>)&#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>);  <span class=\"hljs-comment\">//window</span><br>&#125;, <span class=\"hljs-number\">2000</span>);<br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>数组.forEach/map/filter/find等高阶函数</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> names = [<span class=\"hljs-string\">&quot;aaa&quot;</span>,<span class=\"hljs-string\">&quot;bbb&quot;</span>,<span class=\"hljs-string\">&quot;ccc&quot;</span>,<span class=\"hljs-string\">&quot;ddd&quot;</span>];<br><span class=\"hljs-comment\">// 函数直接独立调用指向window</span><br>names.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">item</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(item,<span class=\"hljs-variable language_\">this</span>);<br>&#125;)<br><span class=\"hljs-comment\">// forEach函数接收两个参数，第一个参数为一个函数，第二个参数为this绑定对象</span><br>names.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">item</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(item,<span class=\"hljs-variable language_\">this</span>);<br>&#125;,<span class=\"hljs-string\">&quot;forEach&quot;</span>)<br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>div的点击</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 2、监听box盒子的点击,内部函数调用实现为：隐式this绑定调用进行打印即boxDiv.onclick()形式调用</span><br><span class=\"hljs-keyword\">const</span> boxDiv = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&quot;.box&quot;</span>);<br><span class=\"hljs-comment\">// 1.方式一：该方式添加监听事件会进行覆盖，也就是后面一个监听事件会覆盖前面一个，只生效一个最后一个事件</span><br>boxDiv.<span class=\"hljs-property\">onclick</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>);<br>&#125;<br><span class=\"hljs-comment\">// 2.方式二：不会进行事件覆盖，会将函数收集到一个数组里面，执行时进行遍历</span><br><span class=\"hljs-comment\">// 内部函数调用实现为：call()方式，即fn.call(boxDiv)</span><br>boxDiv.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;click&quot;</span>,<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>);<br>&#125;)<br>boxDiv.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;click&quot;</span>,<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>);<br>&#125;)<br>boxDiv.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;click&quot;</span>,<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>);<br>&#125;)<br></code></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n",
            "tags": [
                "JavaScript"
            ]
        },
        {
            "id": "http://example.com/2019/01/13/4000_JavaScript/",
            "url": "http://example.com/2019/01/13/4000_JavaScript/",
            "title": "JavaScript",
            "date_published": "2019-01-13T06:12:03.000Z",
            "content_html": "<p>🌸  <span style=\"font-size:bold;color:purple\">您好，欢迎您的阅读，等君久矣，愿与君畅谈.</span><br>\n🔭  <span style=\"font-size:bold;color:purple\">§ 始于颜值 § 陷于才华 § 忠于人品 §</span><br>\n📫  <span style=\"font-size:initial;color:purple\">希望我们可以进一步交流，共同学习，共同探索未知的技术世界 <a href=\"https://juejin.cn/user/2784392994882045\">稀土掘金</a> OR <a href=\"https://github.com/LuckyWishes\">GitHub</a>.</span></p>\n<hr />\n<h2 id=\"1javascript介绍\"><a class=\"markdownIt-Anchor\" href=\"#1javascript介绍\">#</a> 1.JavaScript 介绍</h2>\n<h3 id=\"1javascript应用\"><a class=\"markdownIt-Anchor\" href=\"#1javascript应用\">#</a> 1.JavaScript 应用</h3>\n<ol>\n<li>web 端开发</li>\n<li>移动端开发</li>\n<li>小程序端开发</li>\n<li>桌面应用开发</li>\n<li>后端开发</li>\n</ol>\n<h2 id=\"2javascript运行环境\"><a class=\"markdownIt-Anchor\" href=\"#2javascript运行环境\">#</a> 2.JavaScript 运行环境</h2>\n<h3 id=\"1浏览器工作原理\"><a class=\"markdownIt-Anchor\" href=\"#1浏览器工作原理\">#</a> 1. 浏览器工作原理</h3>\n<ol>\n<li>\n<p>浏览器内核</p>\n<ol>\n<li>Gecko：早期被 Netscape 和 Mozilla、Firefox 浏览器使用，代码完全公开，因此，其可开发程度很高，全世界的程序员都可以为其编写代码，增加功能</li>\n<li>Trident：微软开发的一种排版引擎，被 IE4~IE11 浏览器使用，但是 Edge 浏览器已经转向 Blink</li>\n<li>Webkit：苹果基于 KHTML 开发、开源的，用于 Safari 浏览器，Google Chrome 之前也在使用</li>\n<li>Blink：Google 谷歌基于 webkit 内核开发的，目前应用于 Google Chrome、Edge、Opera 等</li>\n<li>Presto:Opera 浏览器曾经使用过，特点是渲染速度的优化达到了极致，然而代价是牺牲了网页的兼容性</li>\n<li>内核也称排班引擎、浏览器引擎、页面渲染引擎、样板引擎</li>\n</ol>\n</li>\n<li>\n<p>内核工作原理</p>\n<ol>\n<li>浏览器渲染过程，需要将 JavaScript 代码转换为机器语言后交给 CPU 执行<img src=\"../../all_photo/image-20220602085625470.png\" alt=\"image-20220602085625470\"></li>\n</ol>\n</li>\n<li>\n<p><code>Webkit浏览器</code> 内核，由 WebCore 与 JavaScriptCore 两部分组成</p>\n<ol>\n<li>WebCore：负责 HTML、CSS 解析、布局、渲染等相关工作</li>\n<li>JavaScriptCore：解析、执行 JavaScript 代码</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"2v8引擎工作原理\"><a class=\"markdownIt-Anchor\" href=\"#2v8引擎工作原理\">#</a> 2.V8 引擎工作原理</h3>\n<ol>\n<li>\n<p>JavaScript 引擎（V8 引擎是 Google 开发）</p>\n<ol>\n<li>SpiderMonkey：第一款 JavaScript 引擎，由 BrendanEich 开发（也就是 JavaScript 作者）</li>\n<li>Chakra：微软开发，用于 IT 浏览器</li>\n<li>JavaScriptCore：WebKit 中的 JavaScript 引擎，Apple 公司开发</li>\n<li>V8 引擎：Google 开发的强大 JavaScript 引擎，也帮助 Chrome 从众多浏览器中脱颖而出</li>\n</ol>\n</li>\n<li>\n<p>V8 引擎工作原理</p>\n<ol>\n<li>\n<p>V8 定义：C<ins> 编写的 Google 开源高性能 JavaScript 和 webAssembly 引擎，它用于 Chrome 和 Node.js，在很多环境及平台下可以运行，也可以单独运行，也可以嵌入 C</ins> 应用程序中运行</p>\n</li>\n<li>\n<p>Parse：转换器，Parse 模块会将 JavaScript 代码转换成 AST (抽象语法树), 这是因为解释器并不直接认识 JavaScript 代码，如果函数没有被调用，那么是不会被转换成 AST (词法分析: <code>Scanner</code>  转换生成多个 tokens:[{type:‘keyword’,value:‘const’}] 等、语法分析、)</p>\n<blockquote>\n<p>注意:js 代码转换为 AST 抽象语法树网站 (<a href=\"https://astexplorer.net/\">https://astexplorer.net/</a>)</p>\n</blockquote>\n</li>\n<li>\n<p>lgnition：解释器，会将 AST 转换成 ByteCode（字节码）, 因为编写代码运行在具体什么样环境并不清楚，所以需要将该代码转换为字节码，字节码可以运行在各个环境，同时会收集 TurboFan 优化所需要的信息 (比如函数参数的类型信息，有了类型才能进行真实的运算), 如果函数只调用一次，Ignition 会解释执行字节码 ByteCode</p>\n</li>\n<li>\n<p>TurboFan：编译器，可以将字节码编译为 CPU 可以直接执行的机器码；如果一个函数被多次调用，那么就会被标记为 <code>热点函数</code> ，那么就会经过 TurboFan 转换成优化的机器码，提高代码的执行性能；但是机器码实际上也会被还原为 ByteCode，这是因为如果后续执行函数的过程中，类型发生了变化（比如 sum 函数原来执行的是 number 类型，后来执行变成了 string 类型），之前优化的机器码并不能正确的处理运算，就会逆向的经过 <code>Deoptimization</code>  优化转换成字节码，继续进行执行 (从这一点也可以看出 typescript 代码运行效率会好一些，因为在编写时就已经确定参数的类型，减少了逆向转换为字节码再一次进行运行编译为汇编语言然后机器代码，越过这个过程就会快一些)</p>\n</li>\n<li>\n<p>Orinoco：垃圾回收，将程序中不需要的内存回收？？？</p>\n</li>\n<li>\n<p>执行原理过程</p>\n<p><img src=\"../../all_photo/image-20220704154715013.png\" alt=\"image-20220704154715013\"></p>\n</li>\n<li>\n<p>官方执行原理过程</p>\n<p><img src=\"../../all_photo/image-20220704160009294.png\" alt=\"image-20220704160009294\"></p>\n</li>\n<li>\n<p>JavaScript 源码解析过程</p>\n<ol>\n<li>Blink 将源码交给 V8 引擎，Stream 获取到源码并且进行编码转换</li>\n<li>Scanner 会进行词法分析（lexical analysis），词法分析会将代码转换成各种 tokens</li>\n<li>接下来 tokens 会被转换成 AST 树，经过 Parser 和 PreParser\n<ol>\n<li>Parser 就是直接将 tokens 转成 AST 树架构</li>\n<li>PreParser 称之为预解析\n<ol>\n<li>因为并不是所有的 JavaScript 代码，在一开始时就会被执行。那么对所有的 JavaScript 代码进行解析，必然会影响网页的运行效率</li>\n<li>所以 V8 引擎就实现了 Lazy Parsing（延迟解析）的方案，它的作用是将不必要的函数进行预解析，也就是只解析暂时需要的内容，而对<strong>函数的全量解析</strong>是在<strong>函数被调用时</strong>才会进行</li>\n<li>比如我们在一个函数 outer 内部定义了另外一个函数 inner，那么 inner 函数就会进行预解析，生成 AST 树后，会被 Ignition 转成字节码（bytecode）, 之后的过程就是代码的执行过程（后续会详细分析）</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p>JavaScript 源码执行具体操作</p>\n<ol>\n<li>初始化全局对象\n<ol>\n<li>js 引擎会在执行代码之前，会在堆内存中创建一个全局对象：Global Object（GO）</li>\n<li>该对象所有的作用域（scope）都可以访问，里面会包含 Date、Array、String、Number、setTimeout、setInterval 等等，其中有一个 window 属性指向自己</li>\n</ol>\n</li>\n<li>执行上下文栈 (调用栈)\n<ol>\n<li>js 引擎内部有一个执行上下文栈 (Execution Context Stack, 简称 ECS), 它是用于执行代码的调用栈</li>\n<li>该栈执行的是全局代码块，全局的代码块为了执行会构建一个 Global Execution Context (GEC: 全局执行上下文),GEC 会被放入到 ECS 中执行</li>\n<li>GEC 被放入到 ECS 中里面包含两部分内容\n<ol>\n<li>在代码执行前，在 parser 转成 AST 的过程中，会将全局定义的变量、函数等加入到 GlobalObject 中，但是并不会赋值，这个过程也称之为变量的作用域提升（hoisting）</li>\n<li>在代码执行中，对变量赋值，或者执行其他的函数</li>\n</ol>\n</li>\n<li>在执行的过程中执行到一个函数时，就会根据函数体创建一个函数执行上下文（Functional Execution Context，简称 FEC），并且压入到 EC Stack 中</li>\n<li>FEC 中包含三部分内容\n<ol>\n<li>在解析函数成为 AST 树结构时，会创建一个 Activation Object (AO):AO 中包含形参、arguments、函数定义和指向函数对象、定义的变量（<strong>VO:AO</strong>）</li>\n<li>作用域链：由 VO（在函数中就是 AO 对象）和父级 VO 组成，查找时会一层层查找</li>\n<li>this 绑定的值：根据不同的情况绑定 this</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>变量环境和记录 ( <code>作用域链考点</code> )\n<ol>\n<li>概念\n<ol>\n<li>VO：全局变量对象，创建执行上下文时与之关联的会有一个变量对象，该上下文中的所有变量和函数全都保存在这个对象中</li>\n<li>GO：全局对象，进入到一个执行上下文时，此执行上下文中的变量和函数都可以被访问 (全局)</li>\n<li>AO：私有变量对象 (函数即将被执行，还没有还执行)，进入到一个执行上下文时，此执行上下文中的变量和函数都可以被访问 (局部)</li>\n<li>GEC (global excution context) 全局执行上下文：执行全局代码，FEC (function excution context) 函数执行上下文：执行函数代码</li>\n<li><strong>函数的作用域与函数定义位置有关，与调用位置无关</strong></li>\n</ol>\n</li>\n<li>早期 ECMA 版本规范：每一个执行上下文被关联到一个变量对象 (variable,VO), 在源代码中的变量和函数声明会被作为属性添加到 VO 中，对于函数来说，参数也会被添加到 VO 中</li>\n<li>在最新的 ECMA 的版本规范中，已经修改不称作 VO、GO、AO 等，而是称为变量环境，每添加的变量、函数叫作环境记录。每一个执行上下文会关联到一个 <code>变量环境</code>  (VariableEnvironment 简称 VE) 中，在执行代码中变量和函数的声明会作为 <code>环境记录</code>  (Environment Record) 添加到变量环境中，对于函数来说，参数也会被作为环境记录添加到变量环境中</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"3javascript内存原理\"><a class=\"markdownIt-Anchor\" href=\"#3javascript内存原理\">#</a> 3.JavaScript 内存原理</h3>\n<ol>\n<li>内存管理\n<ol>\n<li>内存的管理有如下的生命周期\n<ol>\n<li>分配所申请的内存空间</li>\n<li>使用所分配的内存空间</li>\n<li>不使用时进行释放</li>\n</ol>\n</li>\n<li>管理内存的方式\n<ol>\n<li>手动管理内存：C、C++</li>\n<li>自动管理内存：Java、JavaScript、python、Swift、Dart</li>\n</ol>\n</li>\n<li>内存分配\n<ol>\n<li>JS 对于基本数据类型内存的分配会在执行时，直接在栈空间进行分配</li>\n<li>对于复杂数据类型内存的分配会在堆内存中开辟一块空间，并且将这块空间的指针返回值变量引用</li>\n</ol>\n</li>\n<li>JS 的垃圾回收，Garbage Collection，简称<strong> GC</strong>\n<ol>\n<li>不再使用的对象，称之为垃圾，需要被回收释放更多的内存空间</li>\n<li>Java 的运行环境 JVM，JavaScript 的运行环境 js 引擎都会有内存垃圾回收器</li>\n<li>GC 算法\n<ol>\n<li>引用计数：内存中存在一个引用计数，retain count：默认为 0，缺点可能会产生循环引用</li>\n<li><strong>标记清除</strong>：设置一个根对象 (root object), 垃圾回收器会定期从这个根开始，找所有从开始有引用的对象，对于没有引用的对象，就认为是不可用对象</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>常见 GC 内存算法\n<ol>\n<li>JavaScript 垃圾回收</li>\n<li>引用计数算法</li>\n<li>标记清除算法</li>\n<li>标记整理算法</li>\n<li>分代回收算法</li>\n</ol>\n</li>\n<li>V8 引擎内存管理\n<ol>\n<li>V8 的分代算法</li>\n<li>V8 的内存分配</li>\n<li>新生代对象回收</li>\n<li>旧生代对象回收</li>\n</ol>\n</li>\n<li>Performmance 调试</li>\n<li>JavaScript 内存泄漏</li>\n<li>严格模式\n<ol>\n<li>概念\n<ol>\n<li>严格模式是一种具有限制性的 JavaScript 模式，从而使代码隐式的脱离了 <code>懒散（sloppy）模式</code></li>\n<li>支持严格模式的浏览器在检测到代码中有严格模式时，会以更加严格的方式对代码进行检测和执行</li>\n<li>严格模式对正常的 JavaScript 语义进行了一些限制\n<ol>\n<li>严格模式通过抛出错误来消除一些原有的静默（silent）错误</li>\n<li>严格模式让 JS 引擎在执行代码时可以进行更多的优化（不需要对一些特殊的语法进行处理）</li>\n<li>严格模式禁用了在 ECMAScript 未来版本中可能会定义的一些语法</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>开启严格模式\n<ol>\n<li>支持在 js 文件中开启严格模式</li>\n<li>支持对某一个函数开启严格模式</li>\n<li>严格模式通过在文件或者函数开头使用 use strict 来开启</li>\n</ol>\n</li>\n<li>严格模式限制\n<ol>\n<li>禁止意外创建全局变量</li>\n<li>不允许函数有相同的参数名称</li>\n<li>出现静默错误</li>\n<li>不允许使用原先的八进制格式</li>\n<li>with 语句不允许使用</li>\n<li>eval 函数不会向上引用变量 (不会再向上层作用域添加变量)</li>\n<li>严格模式下试图删除不可删除的属性</li>\n<li>严格模式下，this 绑定不会默认转成对象</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"4javascript事件循环\"><a class=\"markdownIt-Anchor\" href=\"#4javascript事件循环\">#</a> 4.JavaScript 事件循环</h3>\n<ol>\n<li>浏览器的进程模式\n<ol>\n<li>进程</li>\n<li>线程</li>\n<li>JavaScript 线程</li>\n</ol>\n</li>\n<li>浏览器的事件循环\n<ol>\n<li>宏任务 macrotask</li>\n<li>微任务 microtask</li>\n<li>常见面试题</li>\n</ol>\n</li>\n<li>Node 的事件循环\n<ol>\n<li>libuv</li>\n<li>阻塞 IO</li>\n<li>非阻塞 IO</li>\n<li>宏任务 macrotask</li>\n<li>微任务 microtask</li>\n<li>常见面试题</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"3javascript作用域和函数\"><a class=\"markdownIt-Anchor\" href=\"#3javascript作用域和函数\">#</a> 3.JavaScript 作用域和函数</h2>\n<h3 id=\"1认识作用域\"><a class=\"markdownIt-Anchor\" href=\"#1认识作用域\">#</a> 1. 认识作用域</h3>\n<ol>\n<li>\n<p>认识作用域</p>\n<ol>\n<li>JavaScript 编译、执行</li>\n<li>深入理解作用域</li>\n<li>作用域的嵌套</li>\n</ol>\n</li>\n<li>\n<p>词法作用域</p>\n<ol>\n<li>\n<p>认识词法分析</p>\n</li>\n<li>\n<p>eval 函数</p>\n<ol>\n<li>eval 是一个特殊的函数，可以将传入的字符串当作 JavaScript 代码来运行</li>\n<li>不建议在开发中使用\n<ol>\n<li>eval 代码可读性较差</li>\n<li>eval 是一个字符串，可能在执行过程中被篡改，造成恶意攻击</li>\n<li>eval 的执行必须经过 JS 解释器，不能被 JS 引擎优化</li>\n</ol>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> jsString = <span class=\"hljs-string\">&#x27;var message = &quot;Hello World~~&quot;;console.log(message);&#x27;</span>;<br><span class=\"hljs-built_in\">eval</span>(jsString);<br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p>with 关键字</p>\n<ol>\n<li><code>with</code>  的使用，但不推荐使用，在严格模式下会报错</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// &quot;use strict&quot;</span><br><span class=\"hljs-keyword\">var</span> message = <span class=\"hljs-string\">&quot;Hello world!&quot;</span>;<br><span class=\"hljs-keyword\">var</span> object = &#123;<br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;tests&quot;</span>,<br>  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">12</span>,<br>  <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">&quot;您好&quot;</span><br>&#125;;<br><span class=\"hljs-comment\">// with语句:可以形成自己的作用域</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">bar</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">with</span> (object) &#123;<br>      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(message);<br>    &#125;<br>  &#125;<br>  <span class=\"hljs-title function_\">bar</span>();<br>&#125;<br><span class=\"hljs-title function_\">foo</span>();<br></code></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li>\n<p>作用域提升</p>\n<ol>\n<li>编译器中变量声明和提升</li>\n<li>函数和变量的提升</li>\n</ol>\n</li>\n<li>\n<p>块级作用域</p>\n<ol>\n<li>with 作用域\n<ol>\n<li><code>with</code>  可以自己形成作用域，先查找传进来的对象，之后再去上层查找</li>\n</ol>\n</li>\n<li><code>try...catch...</code>  作用域</li>\n<li>let 变量声明</li>\n<li>const 变量声明</li>\n</ol>\n</li>\n<li>\n<p>作用域面试题</p>\n</li>\n</ol>\n<h3 id=\"2执行上下文\"><a class=\"markdownIt-Anchor\" href=\"#2执行上下文\">#</a> 2. 执行上下文</h3>\n<ol>\n<li>执行上下文\n<ol>\n<li>Global EC</li>\n<li>Function EC</li>\n<li>Eval EC</li>\n</ol>\n</li>\n<li>变量对象 VO\n<ol>\n<li>VO: 全局变量对象</li>\n<li>AO: 私有变量对象</li>\n<li>GO: 全局对象</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"3深入函数执行\"><a class=\"markdownIt-Anchor\" href=\"#3深入函数执行\">#</a> 3. 深入函数执行</h3>\n<ol>\n<li>\n<p><code>call/apply执行函数</code></p>\n</li>\n<li>\n<p>立即执行函数</p>\n</li>\n<li>\n<p><code>Scopechain</code></p>\n</li>\n<li>\n<p><strong> <code>深入闭包</code> </strong></p>\n<ol>\n<li>\n<p>补充</p>\n<ol>\n<li>高阶函数：一个函数接收另一个函数作为参数或者一个函数会作为另一个函数的返回值返回</li>\n<li><code>filter</code> : 过滤，接收一个<strong>返回布尔类型的函数为参数</strong>，并且该函数具有三个参数分别为数组中的元素、数组中的元素的下标、数组本身</li>\n<li><code>map</code> : 映射，</li>\n<li><code>forEach</code> : 迭代遍历，无返回值</li>\n<li><code>find</code> : 查找的为一个对象</li>\n<li><code>findIndex</code> : 查找的为对象索引值</li>\n<li><code>reduce</code> : 累加计算</li>\n<li>方法：对象里面的函数（特殊位置的函数），函数：独立的 function 称为函数</li>\n</ol>\n</li>\n<li>\n<p><code>闭包:Closure</code></p>\n<ol>\n<li>\n<p>维基百科：闭包又称词法闭包、函数闭包，是在支持头等函数的编程语言中，实现词法绑定的一种技术，闭包在实现上是一个结构体，它存储了一个函数和一个关联的环境，闭包和普通函数的区别在于，<strong>当捕捉闭包的时候，它的自由变量会在捕捉时被确定</strong>，这样即使脱离了捕捉时的上下文，它也能照常运行</p>\n</li>\n<li>\n<p>MDN：<strong>一个函数和对其周围状态 (词法环境) 的引用捆绑</strong>在一起 (说函数被引用包围)，这样的组合就是闭包，闭包让你可以在一个内层函数中访问到其外层函数的作用域，在 JavaScript 中，每当创建一个函数，闭包就会在函数创建时被创建出来</p>\n</li>\n<li>\n<p>个人理解：<strong>一个普通的函数，如果它可以访问到外层作用域的自由变量，那么这个函数就是一个闭包。从广义角度：(可以访问到) JavaScript 中的函数都是闭包；从狭义角度 (有访问到)：JavaScript 中的一个函数，若访问了外层作用域的自由变量，那么它就是一个闭包</strong></p>\n</li>\n<li>\n<p>闭包引起的内存泄漏</p>\n<ol>\n<li>使用完毕后本该销毁的内存而没有销毁继续存在称为内存泄露</li>\n<li>内存释放将其设置为 <code>null</code>  即可</li>\n</ol>\n</li>\n<li>\n<p>闭包中引用的自由变量</p>\n<ol>\n<li>AO 对象不会被销毁时，该对象里面被闭包引用的自由变量不会被销毁，没有引用的自由变量会被 js 引擎销毁</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">var</span> name = <span class=\"hljs-string\">&quot;GXX&quot;</span>;<br>  <span class=\"hljs-keyword\">var</span> age = <span class=\"hljs-number\">19</span>;<br>  <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">bar</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">debugger</span><br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(name);<br>    <span class=\"hljs-comment\">// 按照ECAM规范整个foo函数的AO对象不会删除，所以该对象中的age属性也应该存在，但是浏览器的js引擎即V8引擎会进行优化将其删除掉</span><br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(age);<span class=\"hljs-comment\">//bar函数中不访问变量age</span><br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> bar;<br>&#125;<br><span class=\"hljs-keyword\">var</span> fn = <span class=\"hljs-title function_\">foo</span>();<br><span class=\"hljs-title function_\">fn</span>();<br></code></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"4函数的this绑定\"><a class=\"markdownIt-Anchor\" href=\"#4函数的this绑定\">#</a> 4. 函数的 this 绑定</h3>\n<ol>\n<li>\n<p>全局作用域下</p>\n<ol>\n<li>\n<p>浏览器环境：全局作用域下 <code>this</code>  绑定 window</p>\n</li>\n<li>\n<p>node 环境： <code>空对象&#123;&#125;</code></p>\n<ol>\n<li>执行步骤：首先将要执行的 js 文件作为模块，然后进行加载编译，此时将 js 代码所有文件放入一个函数中，执行该函数，但是该函数调用 <code>call()</code> , 在调用时向 <code>call()</code>  中传入一个空对象绑定为 <code>this</code>  即 <code>执行函数.call(&#123;&#125;)</code></li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p><em>函数作用域下</em> <code>this</code>  指向</p>\n<ol>\n<li>\n<p>函数在被调用时，JavaScript 会默认给 this 绑定一个值，this 指向与函数所处位置 (<strong>函数定义位置</strong>) 无关，与<strong>函数被调用的方式</strong>及调用位置有关，<strong>this 是在运行时被绑定</strong></p>\n</li>\n<li>\n<p><strong>默认绑定</strong></p>\n<ol>\n<li>\n<p>独立函数调用 <code>this</code>  指向的是全局对象 <code>window</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>);<br>&#125;<br><span class=\"hljs-keyword\">var</span> obj1 = &#123;<br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;obj1&quot;</span>,<br>  <span class=\"hljs-attr\">foo</span>: foo<br>&#125;<br><span class=\"hljs-comment\">// 将obj1的foo赋值给bar</span><br><span class=\"hljs-keyword\">var</span> bar = obj1.<span class=\"hljs-property\">foo</span>;<br><span class=\"hljs-title function_\">bar</span>();<br></code></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li>\n<p><strong>隐式绑定</strong></p>\n<ol>\n<li>\n<p>通过某个对象进行调用，即调用位置中是<strong>通过某个对象发起的函数调用</strong> (谁发起函数调用 this 就绑定谁)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>);<br>&#125;<br><span class=\"hljs-keyword\">var</span> test = &#123;<br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;test&quot;</span>,<br>  <span class=\"hljs-attr\">foo</span>: foo<br>&#125;<br><span class=\"hljs-keyword\">var</span> obj1 = &#123;<br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;obj1&quot;</span>,<br>  <span class=\"hljs-attr\">test</span>: test<br>&#125;<br><span class=\"hljs-keyword\">var</span> obj2 = &#123;<br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;obj2&quot;</span>,<br>  <span class=\"hljs-attr\">obj1</span>: obj1<br>&#125;<br>obj2.<span class=\"hljs-property\">obj1</span>.<span class=\"hljs-property\">test</span>.<span class=\"hljs-title function_\">foo</span>();<span class=\"hljs-comment\">//test对象</span><br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>object.fn()</code> ：object 对象会被 js 引擎绑定到 fn 函数中的 this 上</p>\n</li>\n<li>\n<p>隐式绑定的前提条件</p>\n<ol>\n<li>必须在调用的对象内部有一个对函数的引用（比如一个属性）</li>\n<li>如果没有这样的引用，在进行调用时，会报找不到该函数的错误</li>\n<li>正是通过这个引用，间接的将 this 绑定到了这个对象上</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p><strong>显示绑定</strong></p>\n<ol>\n<li>\n<p><code>call()</code></p>\n<ol>\n<li>第一个参数为绑定对象，第二个参数为参数列表 (剩余参数形式)</li>\n</ol>\n</li>\n<li>\n<p><code>apply()</code></p>\n<ol>\n<li>第一个参数为绑定对象，第二个参数为参数列表 (数组形式)</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-params\">num1,num2,num3</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(num1+num2+num3,<span class=\"hljs-variable language_\">this</span>);<br>&#125;<br>sum.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-string\">&quot;call&quot;</span>,<span class=\"hljs-number\">20</span>,<span class=\"hljs-number\">30</span>,<span class=\"hljs-number\">40</span>);<span class=\"hljs-comment\">//剩余参数形式</span><br>sum.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-string\">&quot;apply&quot;</span>,[<span class=\"hljs-number\">20</span>,<span class=\"hljs-number\">30</span>,<span class=\"hljs-number\">40</span>]);<span class=\"hljs-comment\">//数组形式</span><br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>bind()</code></p>\n<ol>\n<li>第一个参数为绑定对象，第二个参数为参数列表 (剩余参数形式), <code>bind</code>  返回为一个新的函数</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>);<br>&#125;<br><span class=\"hljs-comment\">// 默认绑定和显示绑定bind冲突：优先级（显示绑定）</span><br><span class=\"hljs-keyword\">var</span> newFoo = foo.<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-string\">&quot;aaaa&quot;</span>);<br><span class=\"hljs-title function_\">newFoo</span>();<br></code></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li>\n<p><strong>new 绑定</strong></p>\n<ol>\n<li>使用 new 关键字来调用函数执行如下的操作\n<ol>\n<li>创建一个全新的对象，<strong>并将该对象赋值给 this，函数最后返回该对象</strong></li>\n<li>这个新对象会被执行 prototype 连接</li>\n<li>这个新对象会绑定到函数调用的 this 上（this 的绑定在这个步骤完成）</li>\n<li>如果函数没有返回其他对象，表达式会返回这个新对象</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p><strong>内置函数绑定</strong></p>\n<ol>\n<li>\n<p><code>setTimeout</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 因为setTimeout内部实现函数调用时为独立函数调用，所以打印this时指向window</span><br><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>)&#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>);  <span class=\"hljs-comment\">//window</span><br>&#125;, <span class=\"hljs-number\">2000</span>);<br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>数组.forEach/map/filter/find等高阶函数</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> names = [<span class=\"hljs-string\">&quot;aaa&quot;</span>,<span class=\"hljs-string\">&quot;bbb&quot;</span>,<span class=\"hljs-string\">&quot;ccc&quot;</span>,<span class=\"hljs-string\">&quot;ddd&quot;</span>];<br><span class=\"hljs-comment\">// 函数直接独立调用指向window</span><br>names.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">item</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(item,<span class=\"hljs-variable language_\">this</span>);<br>&#125;)<br><span class=\"hljs-comment\">// forEach函数接收两个参数，第一个参数为一个函数，第二个参数为this绑定对象</span><br>names.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">item</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(item,<span class=\"hljs-variable language_\">this</span>);<br>&#125;,<span class=\"hljs-string\">&quot;forEach&quot;</span>)<br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>div的点击</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 2、监听box盒子的点击,内部函数调用实现为：隐式this绑定调用进行打印即boxDiv.onclick()形式调用</span><br><span class=\"hljs-keyword\">const</span> boxDiv = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&quot;.box&quot;</span>);<br><span class=\"hljs-comment\">// 1.方式一：该方式添加监听事件会进行覆盖，也就是后面一个监听事件会覆盖前面一个，只生效一个最后一个事件</span><br>boxDiv.<span class=\"hljs-property\">onclick</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>);<br>&#125;<br><span class=\"hljs-comment\">// 2.方式二：不会进行事件覆盖，会将函数收集到一个数组里面，执行时进行遍历</span><br><span class=\"hljs-comment\">// 内部函数调用实现为：call()方式，即fn.call(boxDiv)</span><br>boxDiv.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;click&quot;</span>,<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>);<br>&#125;)<br>boxDiv.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;click&quot;</span>,<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>);<br>&#125;)<br>boxDiv.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;click&quot;</span>,<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>);<br>&#125;)<br></code></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p><strong>规则的优先级</strong></p>\n<ol>\n<li>\n<p><strong>new 绑定 &gt; 显示绑定 (bind/call/apply) &gt; 隐式绑定 (object.foo ()) &gt; 默认绑定 (独立函数调用)</strong></p>\n</li>\n<li>\n<p>默认规则 (独立调用) 的优先级最低</p>\n</li>\n<li>\n<p>显示绑定优先级高于隐式绑定</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> object = &#123;<br>  <span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">&quot;object&quot;</span>,<br>  <span class=\"hljs-attr\">foo</span>:<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>);<br>  &#125;<br>&#125;<br>object.<span class=\"hljs-title function_\">foo</span>();<br>object.<span class=\"hljs-property\">foo</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-string\">&quot;call&quot;</span>);<span class=\"hljs-comment\">//call()绑定</span><br>object.<span class=\"hljs-property\">foo</span>.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-string\">&quot;apply&quot;</span>);<span class=\"hljs-comment\">//apply()绑定</span><br><span class=\"hljs-keyword\">var</span> bar = object.<span class=\"hljs-property\">foo</span>.<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-string\">&quot;bind&quot;</span>);<br><span class=\"hljs-title function_\">bar</span>();<br><span class=\"hljs-comment\">//bind()绑定优先级比较</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>);<br>&#125;<br><span class=\"hljs-keyword\">var</span> object = &#123;<br>  <span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">&quot;object&quot;</span>,<br>  <span class=\"hljs-attr\">foo</span>:foo.<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-string\">&quot;bind&quot;</span>)<br>&#125;<br>object.<span class=\"hljs-title function_\">foo</span>();<br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p>new 绑定优先级高于隐式绑定</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> object = &#123;<br>  <span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">&quot;GXX&quot;</span>,<br>  <span class=\"hljs-attr\">foo</span>:<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>);<br>  &#125;<br>&#125;<br><span class=\"hljs-comment\">// new的优先级高于隐式绑定</span><br><span class=\"hljs-keyword\">var</span> fn = <span class=\"hljs-keyword\">new</span> object.<span class=\"hljs-title function_\">foo</span>();<br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p>new 绑定优先级高于 bind</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 结论：new关键字不能和apply/call一起来使用</span><br><span class=\"hljs-comment\">// new VS bind</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>);<br>&#125;<br><span class=\"hljs-keyword\">var</span> bar = foo.<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-string\">&quot;bind&quot;</span>);<br><span class=\"hljs-keyword\">var</span> object = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">bar</span>();<br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p>特殊情况 —— 忽略显示绑定</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>);<br>&#125;<br>foo.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-string\">&quot;call&quot;</span>);<br>foo.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-string\">&quot;apply&quot;</span>);<br><span class=\"hljs-comment\">// apply/call/bind:当传入null/undefined时，自动将this绑定成全局对象</span><br>foo.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-literal\">null</span>);<br>foo.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-literal\">undefined</span>); <br><span class=\"hljs-keyword\">var</span> fn = foo.<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-literal\">null</span>);<br><span class=\"hljs-comment\">// var fn = foo.bind(undefined);</span><br><span class=\"hljs-title function_\">fn</span>(); <br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p>特殊情况 —— 间接函数引用</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> object1 = &#123;<br>  <span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">&quot;object1&quot;</span>,<br>  <span class=\"hljs-attr\">foo</span>:<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>);<br>  &#125;<br>&#125;;<br><span class=\"hljs-keyword\">var</span> object2 = &#123;<br>  <span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">&quot;object2&quot;</span><br>&#125;;<br>object2.<span class=\"hljs-property\">bar</span> = object1.<span class=\"hljs-property\">foo</span>;<br>object2.<span class=\"hljs-title function_\">bar</span>();<span class=\"hljs-comment\">//打印object2对象</span><br><span class=\"hljs-comment\">// 立即执行函数(匿名函数)，当作独立函数调用，打印全局对象window</span><br>(object2.<span class=\"hljs-property\">bar</span> = object1.<span class=\"hljs-property\">foo</span>)();<br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p>特殊情况 ——ES6 箭头函数</p>\n<ol>\n<li>根据外层作用域来决定 <code>this</code>  指向</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> object =&#123;<br>  <span class=\"hljs-attr\">data</span>:[],<br>  <span class=\"hljs-attr\">getData</span>:<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br><span class=\"hljs-comment\">/*     // 发送网络请求，将结果放到上面data属性中</span><br><span class=\"hljs-comment\">    // 在箭头函数之前的解决方案</span><br><span class=\"hljs-comment\">    // 使用闭包</span><br><span class=\"hljs-comment\">    var _this = this;</span><br><span class=\"hljs-comment\">    setTimeout(() =&gt; &#123;</span><br><span class=\"hljs-comment\">      var result = [&quot;111&quot;,&quot;222&quot;,&quot;333&quot;,&quot;444&quot;];</span><br><span class=\"hljs-comment\">      _this.data = result;</span><br><span class=\"hljs-comment\">    &#125;, 2000); */</span><br>    <br>    <span class=\"hljs-comment\">// 箭头函数出现后</span><br>    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>      <span class=\"hljs-keyword\">var</span> result = [<span class=\"hljs-string\">&quot;111&quot;</span>,<span class=\"hljs-string\">&quot;222&quot;</span>,<span class=\"hljs-string\">&quot;333&quot;</span>,<span class=\"hljs-string\">&quot;444&quot;</span>];<br>      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">data</span> = result;<br>    &#125;, <span class=\"hljs-number\">2000</span>);<br>  &#125;<br>&#125;<br><span class=\"hljs-comment\">// 隐式绑定，将getData方法中的this指向object对象，则_this就为object对象，即可拿到result数据</span><br>object.<span class=\"hljs-title function_\">getData</span>();<br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>this指向面试题</code></p>\n<ol>\n<li>\n<p>对象花括号不是作用域</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> object = &#123;<br>\t<span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">&quot;test&quot;</span>,<br>\t<span class=\"hljs-attr\">foo</span>:<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)&#123;<br>\t<span class=\"hljs-comment\">//上层作用域为全局</span><br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p>箭头函数不看绑定，向上层作用域查找</p>\n</li>\n<li>\n<p>一定要看：<strong>执行时看是谁发起函数调用</strong></p>\n</li>\n</ol>\n</li>\n<li>\n<p>箭头函数</p>\n<ol>\n<li>介绍及简写语法练习</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p><strong> <code>call&amp;apply&amp;bind</code> </strong></p>\n<ol>\n<li>\n<p><code>call实现</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 给所有的函数添加一个hycall方法</span><br><span class=\"hljs-title class_\">Function</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">hycall</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">thisArg,...args</span>) &#123;<span class=\"hljs-comment\">//...args没有传入参数是一个空的数组</span><br>  <span class=\"hljs-comment\">// 第一步：获取哪一个函数调用hycall</span><br>  <span class=\"hljs-keyword\">var</span> fn = <span class=\"hljs-variable language_\">this</span>;<br>  <span class=\"hljs-comment\">// 第二步：对thisArg转成对象类型(防止传入的是非对象类型),使用thisArg对象时,当thisArg为字符串、数字、布尔等类型时需要进行转换为对应的对象</span><br>  thisArg = (thisArg !== <span class=\"hljs-literal\">null</span> &amp;&amp; thisArg !== <span class=\"hljs-literal\">undefined</span> &amp;&amp; thisArg == <span class=\"hljs-number\">0</span>) ? <span class=\"hljs-title class_\">Object</span>(thisArg) : <span class=\"hljs-variable language_\">window</span>;<br>  <span class=\"hljs-comment\">// 第三步：调用需要被执行的函数</span><br>  <span class=\"hljs-comment\">// 1、使用call实现</span><br>  <span class=\"hljs-comment\">// fn.call(thisArg);</span><br>  <span class=\"hljs-comment\">// 2、使用thisArg对象实现</span><br>  thisArg.<span class=\"hljs-property\">fn</span> = fn;<br>  <span class=\"hljs-keyword\">var</span> result = thisArg.<span class=\"hljs-title function_\">fn</span>(...args);<span class=\"hljs-comment\">//展开时至少是一个空的数组</span><br>  <span class=\"hljs-comment\">// delete thisArg.fn;</span><br>  <span class=\"hljs-comment\">// 第四步：将最终的结果返回出去</span><br>  <span class=\"hljs-keyword\">return</span> result;<br>&#125;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\">num1,num2</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;foo函数被执行&quot;</span>,<span class=\"hljs-variable language_\">this</span>,num1,num2);<br>&#125;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-params\">num1,num2</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;sum函数被执行&quot;</span>,<span class=\"hljs-variable language_\">this</span>,num1,num2);<br>  <span class=\"hljs-keyword\">return</span> num1 + num2;<br>&#125;<br>foo.<span class=\"hljs-title function_\">hycall</span>(&#123;&#125;);<br>foo.<span class=\"hljs-title function_\">hycall</span>(&#123;&#125;,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>);<br>foo.<span class=\"hljs-title function_\">hycall</span>(<span class=\"hljs-literal\">null</span>);<br>foo.<span class=\"hljs-title function_\">hycall</span>(<span class=\"hljs-literal\">undefined</span>,<span class=\"hljs-number\">6</span>,<span class=\"hljs-number\">6</span>);<br>sum.<span class=\"hljs-title function_\">hycall</span>(<span class=\"hljs-string\">&quot;hycall&quot;</span>,<span class=\"hljs-number\">9</span>,<span class=\"hljs-number\">9</span>);<br><span class=\"hljs-keyword\">var</span> result = <span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-number\">20</span>,<span class=\"hljs-number\">30</span>);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(result);<br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>apply实现</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Function</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">hyapply</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">thisArg,argArray</span>) &#123;<span class=\"hljs-comment\">//argArray没有传入参数是undefined</span><br>  <span class=\"hljs-comment\">// 第一步：获取那一个函数调用hyapply方法</span><br>  <span class=\"hljs-keyword\">var</span> fn = <span class=\"hljs-variable language_\">this</span>;<br>  <span class=\"hljs-comment\">// 第二步：保证传入都是对象类型</span><br>  thisArg = (thisArg !== <span class=\"hljs-literal\">null</span> &amp;&amp; thisArg !== <span class=\"hljs-literal\">undefined</span> &amp;&amp; thisArg == <span class=\"hljs-number\">0</span>) ? <span class=\"hljs-title class_\">Object</span>(thisArg) : <span class=\"hljs-variable language_\">window</span>;<br>  <span class=\"hljs-comment\">// 第三步：调用执行函数</span><br>  thisArg.<span class=\"hljs-property\">fn</span> = fn;<br>  <span class=\"hljs-comment\">// 判断是否传入参数</span><br>  <span class=\"hljs-comment\">// 方式一：!argArray为true没有参数，为false有参数</span><br>  <span class=\"hljs-keyword\">var</span> result = !argArray ? thisArg.<span class=\"hljs-title function_\">fn</span>() : thisArg.<span class=\"hljs-title function_\">fn</span>(...argArray);<br>  <span class=\"hljs-comment\">// 方式二：使用</span><br><br><span class=\"hljs-comment\">/*   // 方式三：使用或运算符</span><br><span class=\"hljs-comment\">  // argArray = argArray ? argArray:[]</span><br><span class=\"hljs-comment\">  argArray = argArray || [];</span><br><span class=\"hljs-comment\">  var result = thisArg.fn(...argArray); */</span><br>  <span class=\"hljs-keyword\">delete</span> thisArg.<span class=\"hljs-property\">fn</span>;<br>  <span class=\"hljs-keyword\">return</span> result;<br>&#125;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-params\">num1,num2</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;sum函数被调用了&quot;</span>,<span class=\"hljs-variable language_\">this</span>,num1,num2);<br>  <span class=\"hljs-keyword\">return</span> num1 + num2;<br>&#125;<br><span class=\"hljs-comment\">// 特殊情况一个参数也需要放入数组中</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\">num</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;foo函数被调用了&quot;</span>,<span class=\"hljs-variable language_\">this</span>,num);<br>  <span class=\"hljs-keyword\">return</span> num;<br>&#125;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">bar</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;bar函数被执行了&quot;</span>,<span class=\"hljs-variable language_\">this</span>);<br>&#125;<br>sum.<span class=\"hljs-title function_\">hyapply</span>(<span class=\"hljs-string\">&quot;test&quot;</span>,[<span class=\"hljs-number\">20</span>,<span class=\"hljs-number\">30</span>]);<br>sum.<span class=\"hljs-title function_\">hyapply</span>(<span class=\"hljs-literal\">null</span>,[<span class=\"hljs-number\">11</span>,<span class=\"hljs-number\">11</span>]);<br><span class=\"hljs-keyword\">var</span> res1 = sum.<span class=\"hljs-title function_\">hyapply</span>(<span class=\"hljs-string\">&quot;hyapply&quot;</span>,[<span class=\"hljs-number\">12</span>,<span class=\"hljs-number\">12</span>]);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res1);<br><span class=\"hljs-keyword\">var</span> res2 = foo.<span class=\"hljs-title function_\">hyapply</span>(<span class=\"hljs-string\">&quot;hyapply&quot;</span>,[<span class=\"hljs-number\">12</span>]);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res2);<br><span class=\"hljs-keyword\">var</span> res3 = bar.<span class=\"hljs-title function_\">hyapply</span>(<span class=\"hljs-string\">&quot;hyapply&quot;</span>);<br><span class=\"hljs-comment\">// 边界判断(edge case)</span><br>bar.<span class=\"hljs-title function_\">hyapply</span>(<span class=\"hljs-number\">0</span>);<br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>bind实现</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Function</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">hybind</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">thisArg, ...argArray</span>) &#123;<br>  <span class=\"hljs-comment\">// 第一步：获取到真实需要调用的函数</span><br>  <span class=\"hljs-keyword\">var</span> fn = <span class=\"hljs-variable language_\">this</span>;<br>  <span class=\"hljs-comment\">// 第二步：绑定this</span><br>  thisArg = (thisArg !== <span class=\"hljs-literal\">null</span> &amp;&amp; thisArg !== <span class=\"hljs-literal\">undefined</span>) ? <span class=\"hljs-title class_\">Object</span>(thisArg) : <span class=\"hljs-variable language_\">window</span>;<br>  <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">proxyFn</span>(<span class=\"hljs-params\">...args</span>) &#123;<br>  <span class=\"hljs-comment\">// 第三步：将函数放到thisArg中进行调用</span><br>    thisArg.<span class=\"hljs-property\">fn</span> = fn;<br>    <span class=\"hljs-comment\">// 特殊处理：对两个传入的参数进行合并</span><br>    <span class=\"hljs-keyword\">var</span> finalArgs = [...argArray, ...args]<br>    <span class=\"hljs-keyword\">var</span> result = thisArg.<span class=\"hljs-title function_\">fn</span>(...finalArgs);<br>    <span class=\"hljs-keyword\">delete</span> thisArg.<span class=\"hljs-property\">fn</span>;<br>  <span class=\"hljs-comment\">// 第四步：返回结果</span><br>    <span class=\"hljs-keyword\">return</span> result;<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> proxyFn;<br>&#125;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;foo函数被调用&quot;</span>, <span class=\"hljs-variable language_\">this</span>);<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">20</span>;<br>&#125;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-params\">num1, num2, num3, num4</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(num1, num2, num3, num4);<br>&#125;<br><span class=\"hljs-comment\">/* // 系统的bind调用</span><br><span class=\"hljs-comment\">var bar = foo.bind(&quot;bind&quot;);</span><br><span class=\"hljs-comment\">bar();</span><br><span class=\"hljs-comment\">// 传入参数的方式</span><br><span class=\"hljs-comment\">// 方式一</span><br><span class=\"hljs-comment\">var newSum = sum.bind(&quot;bind&quot;,11,22,33,44);</span><br><span class=\"hljs-comment\">newSum();</span><br><span class=\"hljs-comment\">// 方式二</span><br><span class=\"hljs-comment\">var newSum = sum.bind(&quot;bind&quot;);</span><br><span class=\"hljs-comment\">newSum(11,22,33,44);</span><br><span class=\"hljs-comment\">// 方式三</span><br><span class=\"hljs-comment\">var newSum = sum.bind(&quot;bind&quot;,11,22);</span><br><span class=\"hljs-comment\">newSum(33,44); */</span><br><span class=\"hljs-comment\">/* var bar = foo.hybind(&quot;hybind&quot;);</span><br><span class=\"hljs-comment\">var res = bar();</span><br><span class=\"hljs-comment\">console.log(res); */</span><br><span class=\"hljs-keyword\">var</span> newSum = sum.<span class=\"hljs-title function_\">hybind</span>(<span class=\"hljs-string\">&quot;hybind&quot;</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>);<br><span class=\"hljs-keyword\">var</span> res = <span class=\"hljs-title function_\">newSum</span>(<span class=\"hljs-number\">30</span>, <span class=\"hljs-number\">40</span>); <br></code></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li>\n<p><strong> <code>arguments</code> </strong></p>\n<ol>\n<li>\n<p>类数组对象 (array-like)，形式像是一个数组，本质上是一个对象，即为对象类型，不能使用数组的方法</p>\n</li>\n<li>\n<p><strong> <code>arguments参数转换数组</code> </strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\">num1,num2</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">arguments</span>);<br>  <span class=\"hljs-comment\">// arguments转换为数组类型方式</span><br><span class=\"hljs-comment\">/*   // 1、使用for循环遍历</span><br><span class=\"hljs-comment\">  var newArray1 = [];</span><br><span class=\"hljs-comment\">  for (let i = 0; i &lt; arguments.length; i++) &#123;</span><br><span class=\"hljs-comment\">    newArray1.push(arguments[i] * 10);</span><br><span class=\"hljs-comment\">  &#125;</span><br><span class=\"hljs-comment\">  console.log(newArray1); */</span><br><span class=\"hljs-comment\">/*   // 2、将arguments转换为array</span><br><span class=\"hljs-comment\">  var newArray2 = Array.prototype.slice.call(arguments);</span><br><span class=\"hljs-comment\">  console.log(newArray2);</span><br><span class=\"hljs-comment\">  var newArray3 = [].slice.call(arguments);</span><br><span class=\"hljs-comment\">  console.log(newArray3); */</span><br>  <span class=\"hljs-comment\">// 3、使用ES6的语法</span><br>  <span class=\"hljs-keyword\">var</span> newArray4 = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(<span class=\"hljs-variable language_\">arguments</span>);<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(newArray4);<br>  <span class=\"hljs-keyword\">var</span> newArray5 = [...<span class=\"hljs-variable language_\">arguments</span>];<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(newArray5);<br>&#125;<br><span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-number\">10</span>,<span class=\"hljs-number\">20</span>,<span class=\"hljs-number\">30</span>,<span class=\"hljs-number\">40</span>,<span class=\"hljs-number\">50</span>,<span class=\"hljs-number\">60</span>);<br><span class=\"hljs-comment\">/* // Array中slice方法实现     </span><br><span class=\"hljs-comment\">Array.prototype.hyslice = function (start,end) &#123;</span><br><span class=\"hljs-comment\">  var array = this;</span><br><span class=\"hljs-comment\">  start = start || 0;</span><br><span class=\"hljs-comment\">  end = end || array.length;</span><br><span class=\"hljs-comment\">  var newArray = [];</span><br><span class=\"hljs-comment\">  for (let i = start; i &lt; end; i++) &#123;</span><br><span class=\"hljs-comment\">    newArray.push(array[i]);</span><br><span class=\"hljs-comment\">  &#125;</span><br><span class=\"hljs-comment\">  return newArray;</span><br><span class=\"hljs-comment\">&#125;</span><br><span class=\"hljs-comment\">// var newArrayFinal = Array.prototype.hyslice.call([&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;],1,3);</span><br><span class=\"hljs-comment\">var newArrayFinal = Array.prototype.hyslice.call([&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;]);</span><br><span class=\"hljs-comment\">console.log(newArrayFinal); */</span><br><span class=\"hljs-comment\">/* // slice方法的使用</span><br><span class=\"hljs-comment\">var names = [&quot;111&quot;,&quot;222&quot;,&quot;333&quot;,&quot;444&quot;];</span><br><span class=\"hljs-comment\">console.log(names.slice(1,3)); */</span><br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p><strong> <code>箭头函数中没有arguments</code> </strong></p>\n<ol>\n<li>浏览器的全局作用域中没有 arguments</li>\n<li>node 环境下存在全局的 arguments</li>\n<li><strong>箭头函数可以使用剩余参数 <code>(...args)</code>  方式获取参数</strong></li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p>编程方式</p>\n<ol>\n<li>函数式编程范式</li>\n<li>面向对象式编程范式</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"5函数的柯里化\"><a class=\"markdownIt-Anchor\" href=\"#5函数的柯里化\">#</a> 5. 函数的柯里化</h3>\n<ol>\n<li>\n<p>纯函数</p>\n<ol>\n<li>\n<p>纯函数的条件</p>\n<ol>\n<li>确定的输入，一定会产生确定的输出</li>\n<li>函数在执行过程中，不能产生副作用</li>\n</ol>\n</li>\n<li>\n<p>副作用理解</p>\n<ol>\n<li>表示在执行一个函数时，除了返回函数值之外，还对调用函数产生了附加的影响，比如修改了全局变量，修改参数或者改变外部的存储</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// test是一个纯函数</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">test</span>(<span class=\"hljs-params\">info</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> &#123;<br>    ...info,<span class=\"hljs-comment\">//展开运算符，对原对象进行浅拷贝，并没有修改原对象</span><br>    <span class=\"hljs-attr\">age</span>:<span class=\"hljs-number\">10</span><br>  &#125;<br>&#125;<br><span class=\"hljs-keyword\">var</span> obj1 = &#123;<br>  <span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">&quot;111&quot;</span>,<br>  <span class=\"hljs-attr\">age</span>:<span class=\"hljs-number\">12</span><br>&#125;<br><span class=\"hljs-keyword\">var</span> obj2 = <span class=\"hljs-title function_\">test</span>(obj1);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj2);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj1);<br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p>纯函数的优势</p>\n<ol>\n<li>安心的编写和安心的使用</li>\n<li>只是单纯实现自己的业务逻辑即可，不需要关心传入的内容是如何获得的或者依赖其他的外部变量是否已经发生了修改</li>\n<li>你在用的时候，你确定你的输入内容不会被任意篡改，并且自己确定的输入，一定会有确定的输出</li>\n</ol>\n</li>\n<li>\n<p>纯函数的案例学习</p>\n<ol>\n<li>展开运算符，对原对象进行浅拷贝，并没有修改原对象</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p>柯里化是什么</p>\n<ol>\n<li>柯里化 (英语：Currying) 又译为 <code>卡瑞化</code> 或 <code>加里化</code></li>\n<li>只传递给函数<strong>一部分参数</strong>来调用它，让它返回<strong>一个函数</strong>去处理<strong>剩余的参数</strong></li>\n</ol>\n</li>\n<li>\n<p>实现柯里化</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//一般函数</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-params\">x,y,z</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> (x+y+z);<br>&#125;<br><span class=\"hljs-comment\">// 使用柯里化技术</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">bax</span>(<span class=\"hljs-params\">x</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">y</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">z</span>) &#123;<br>      <span class=\"hljs-keyword\">return</span> (x+y+z);<br>    &#125;<br>  &#125;<br>&#125;<br><span class=\"hljs-comment\">// 一般函数实现</span><br><span class=\"hljs-keyword\">var</span> result1 = <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">10</span>,<span class=\"hljs-number\">20</span>,<span class=\"hljs-number\">30</span>);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(result1);<br><span class=\"hljs-comment\">// 柯里化实现</span><br><span class=\"hljs-keyword\">var</span> result2 = <span class=\"hljs-title function_\">bax</span>(<span class=\"hljs-number\">11</span>)(<span class=\"hljs-number\">22</span>)(<span class=\"hljs-number\">33</span>);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(result2);<br><span class=\"hljs-comment\">// 简化柯里化操作</span><br><span class=\"hljs-keyword\">var</span> <span class=\"hljs-title function_\">foo</span> = (<span class=\"hljs-params\">x</span>) =&gt; <span class=\"hljs-function\">(<span class=\"hljs-params\">y</span>) =&gt;</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">z</span>) =&gt;</span> &#123;<br> <span class=\"hljs-keyword\">return</span> (x+y+z);<br>&#125;<br><span class=\"hljs-keyword\">var</span> result3 = <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-number\">22</span>)(<span class=\"hljs-number\">33</span>)(<span class=\"hljs-number\">44</span>);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(result3);<br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p><strong>柯里化函数的实现 (自动)</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-params\">x,y,z</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> (x+y+z);<br>&#125;<br><span class=\"hljs-comment\">// 柯里化函数的实现hyCurrying</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">hyCurrying</span>(<span class=\"hljs-params\">fn</span>) &#123;<br>  <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">curried1</span>(<span class=\"hljs-params\">...args1</span>) &#123;<br>    <span class=\"hljs-comment\">// 判断接收参数args和函数本身需要接收的参数数量是否一致</span><br>    <span class=\"hljs-comment\">// 当传入的参数大于等于函数需要的参数时，就执行函数</span><br>    <span class=\"hljs-keyword\">if</span> (args1.<span class=\"hljs-property\">length</span> &gt;= fn.<span class=\"hljs-property\">length</span>) &#123;<br>      <span class=\"hljs-comment\">//方式一</span><br>      <span class=\"hljs-comment\">// return fn(...args1);</span><br><span class=\"hljs-comment\">/*       // 方式二</span><br><span class=\"hljs-comment\">      return fn.call(this,...args1); */</span><br>      <span class=\"hljs-comment\">// 方式三</span><br>      <span class=\"hljs-comment\">// 此处this理解:若curryAdd.apply(&quot;test&quot;)即curried1中的this，把this绑定在fn函数中 </span><br>      <span class=\"hljs-keyword\">return</span> fn.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>,args1);<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>      <span class=\"hljs-comment\">// 没有达到函数所需参数数量时，需要返回一个新的函数，继续来接收参数</span><br>      <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">curried2</span>(<span class=\"hljs-params\">...args2</span>) &#123;<br>        <span class=\"hljs-comment\">// 接收到参数后，需要递归调用curried1来检查函数的参数个数是否达到所需参数的个数</span><br>        <span class=\"hljs-keyword\">return</span> curried1.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>,[...args1,...args2])<br>        <span class=\"hljs-comment\">// return curried1.apply(this,args.concat(args2))</span><br>      &#125;<br>      <span class=\"hljs-keyword\">return</span> curried2;<br>    &#125;<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> curried1;<br>&#125;<br><span class=\"hljs-keyword\">var</span> curryAdd = <span class=\"hljs-title function_\">hyCurrying</span>(add);<br><span class=\"hljs-keyword\">var</span> result1 = <span class=\"hljs-title function_\">curryAdd</span>(<span class=\"hljs-number\">10</span>,<span class=\"hljs-number\">20</span>,<span class=\"hljs-number\">30</span>);<br><span class=\"hljs-keyword\">var</span> result2 = <span class=\"hljs-title function_\">curryAdd</span>(<span class=\"hljs-number\">10</span>)(<span class=\"hljs-number\">20</span>)(<span class=\"hljs-number\">30</span>);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(result1);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(result2);<br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p>柯里化的应用</p>\n<ol>\n<li>\n<p><code>函数的职责单一</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 一般函数实现</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-params\">x, y, z</span>) &#123;<br>  <span class=\"hljs-attr\">x</span>: x + <span class=\"hljs-number\">2</span>;<br>  <span class=\"hljs-attr\">y</span>: y * <span class=\"hljs-number\">2</span>;<br>  <span class=\"hljs-attr\">z</span>: z * z;<br>  <span class=\"hljs-keyword\">return</span> (x + y + z)<br>&#125;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">10</span>,<span class=\"hljs-number\">20</span>,<span class=\"hljs-number\">30</span>));<br><span class=\"hljs-comment\">// 柯里化实现</span><br><span class=\"hljs-keyword\">var</span> <span class=\"hljs-title function_\">bar</span> = (<span class=\"hljs-params\">x</span>) =&gt; &#123;<br>  x+=<span class=\"hljs-number\">2</span>;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">y</span>) =&gt;</span> &#123;<br>    y*=<span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">z</span>) =&gt;</span> &#123;<br>      z*=z;<br>      <span class=\"hljs-keyword\">return</span> (x+y+z);<br>    &#125;<br>  &#125;<br>&#125;<br><span class=\"hljs-keyword\">var</span> result = <span class=\"hljs-title function_\">bar</span>(<span class=\"hljs-number\">10</span>)(<span class=\"hljs-number\">20</span>)(<span class=\"hljs-number\">30</span>);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(result);<br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>逻辑复用</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">/* // 23 + x = ？(x = 任意实数)</span><br><span class=\"hljs-comment\">// 一般函数实现</span><br><span class=\"hljs-comment\">function log(date, type, message) &#123;</span><br><span class=\"hljs-comment\">  console.log(`[$&#123;date.getHours()&#125;:$&#123;date.getMinutes()&#125;][$&#123;type&#125;]:[$&#123;message&#125;]`);</span><br><span class=\"hljs-comment\">&#125;</span><br><span class=\"hljs-comment\">log(new Date(), &quot;DEBUG&quot;, &quot;查询数据错误&quot;);</span><br><span class=\"hljs-comment\">log(new Date(), &quot;DEBUG&quot;, &quot;轮播图的错误&quot;);</span><br><span class=\"hljs-comment\">log(new Date(), &quot;DEBUG&quot;, &quot;查询表单错误&quot;); */</span><br><span class=\"hljs-comment\">// 柯里化实现</span><br><span class=\"hljs-keyword\">var</span> <span class=\"hljs-title function_\">log</span> = date =&gt; <span class=\"hljs-function\"><span class=\"hljs-params\">type</span> =&gt;</span> <span class=\"hljs-function\"><span class=\"hljs-params\">message</span> =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`[<span class=\"hljs-subst\">$&#123;date.getHours()&#125;</span>:<span class=\"hljs-subst\">$&#123;date.getMinutes()&#125;</span>][<span class=\"hljs-subst\">$&#123;type&#125;</span>]:[<span class=\"hljs-subst\">$&#123;message&#125;</span>]`</span>);<br>&#125;<br><span class=\"hljs-comment\">// 柯里化--复用时间逻辑</span><br><span class=\"hljs-keyword\">var</span> nowLog = <span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>());<br><span class=\"hljs-title function_\">nowLog</span>(<span class=\"hljs-string\">&quot;6666&quot;</span>)(<span class=\"hljs-string\">&quot;undefined&quot;</span>);<br><span class=\"hljs-comment\">// 柯里化--复用时间逻辑、错误信息逻辑</span><br><span class=\"hljs-keyword\">var</span> newAndDebug = <span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>())(<span class=\"hljs-string\">&quot;同一类型错误信息&quot;</span>);<br><span class=\"hljs-title function_\">newAndDebug</span>(<span class=\"hljs-string\">&quot;undefined&quot;</span>);<br><span class=\"hljs-title function_\">newAndDebug</span>(<span class=\"hljs-string\">&quot;null&quot;</span>);<br></code></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li>\n<p><code>组合函数</code></p>\n<ol>\n<li>\n<p>将多个函数组合起来，自动依次调用</p>\n</li>\n<li>\n<p>实现组合函数 (多个函数，多个参数)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">hyCompose</span>(<span class=\"hljs-params\">...fns</span>) &#123;<br>  <span class=\"hljs-comment\">// var length = fns.length;</span><br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; fns.<span class=\"hljs-property\">length</span>; i++) &#123;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> fns[i] !== <span class=\"hljs-string\">&#x27;function&#x27;</span>) &#123;<br>      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-title class_\">TypeError</span>(<span class=\"hljs-string\">&quot;Expected arguments are functions&quot;</span>);<br>    &#125;<br>  &#125;<br>  <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">compose</span>(<span class=\"hljs-params\">...args</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> index = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">var</span> result = fns.<span class=\"hljs-property\">length</span> ? fns[index].<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>,args):args;<br>    <span class=\"hljs-keyword\">while</span> (++index &lt; fns.<span class=\"hljs-property\">length</span>) &#123;<br>      result = fns[index].<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-variable language_\">this</span>,result);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> result;<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> compose;<br>&#125;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">double</span>(<span class=\"hljs-params\">num1</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> num1*<span class=\"hljs-number\">2</span>;<br>&#125;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">square</span>(<span class=\"hljs-params\">num2</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> num2**<span class=\"hljs-number\">2</span>;<br>&#125;<br><span class=\"hljs-keyword\">var</span> newFn = <span class=\"hljs-title function_\">hyCompose</span>(double,square);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">newFn</span>(<span class=\"hljs-number\">10</span>));<br></code></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"4javascript面向对象\"><a class=\"markdownIt-Anchor\" href=\"#4javascript面向对象\">#</a> 4.JavaScript 面向对象</h2>\n<h3 id=\"1深入理解对象\"><a class=\"markdownIt-Anchor\" href=\"#1深入理解对象\">#</a> 1. 深入理解对象</h3>\n<ol>\n<li>\n<p>补充</p>\n<ol>\n<li>JavaScript 支持多种编程范式，包括函数式编程、面向对象编程</li>\n<li>JavaScript 中的对象被设计成一组属性的无序集合，类似哈希表</li>\n<li>key 是一个标识符名称，value 可以是任意类型，也可以是其他对象或者函数类型</li>\n<li>如果值是一个函数，那么我们可以称之为是对象的方法</li>\n</ol>\n</li>\n<li>\n<p>对象的语法</p>\n<ol>\n<li>创建对象的两种方式\n<ol>\n<li>使用 <code>new</code>  关键字及 <code>Object类</code> 进行创建</li>\n<li>通过字面量进行创建</li>\n</ol>\n</li>\n<li>对象字面量</li>\n<li>对象的类型</li>\n<li>函数对象</li>\n</ol>\n</li>\n<li>\n<p>对象的内容</p>\n<ol>\n<li>\n<p>属性和方法定义</p>\n<ol>\n<li>对象方法补充\n<ol>\n<li><code>preventExtensions</code> : 禁止对象扩展新属性</li>\n<li><code>seal</code> : 密封对象，不允许配置和删除属性，禁止对象配置 / 删除里面的属性即设置 <code>configurable:false</code></li>\n<li><code>freeze</code> : 冻结对象，不允许修改现有的属性，使属性不可以修改即设置 <code>writable:false</code></li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p>对象属性描述符</p>\n<ol>\n<li>\n<p>想要对一个属性进行比较精准的操作控制，那么我们就可以使用属性描述符</p>\n</li>\n<li>\n<p>通过属性描述符可以精准的添加或修改对象的属性</p>\n</li>\n<li>\n<p>属性描述符需要使用 ** <code>Object.defineProperty()</code> ** 来对属性进行添加或者修改</p>\n</li>\n<li>\n<p><code>Object.defineProperty(obj,prop,descriptor)</code></p>\n<ol>\n<li><code>obj</code> : 需要定义属性的对象</li>\n<li><code>prop</code> : 将要定义或修改的属性名称或 <code>Symbol</code></li>\n<li><code>descriptor</code> : 将要定义或修改的<strong>属性描述符</strong></li>\n<li>该方式添加的属性默认是不可枚举的</li>\n</ol>\n</li>\n<li>\n<p><strong> <code>Object.defineProperties()</code> </strong>: 在一个对象上定义多个新的属性或修改现有属性，返回该对象</p>\n</li>\n<li>\n<p>属性描述符</p>\n<ol>\n<li>\n<p>数据属性描述符</p>\n<ol>\n<li><code>configurable</code> : 属性是否可以通过 delete 删除属性，是否可以修改它的特性，或者是否可以将它修改为存取属性描述符\n<ol>\n<li>当我们直接在一个对象上定义某个属性时，这个属性的 [Configurable] 为 true</li>\n<li>当我们通过属性描述符定义一个属性时，这个属性的 [Configurable] 默认为 false</li>\n</ol>\n</li>\n<li><code>enumerable</code> : 属性是否可以通过 for-in 或者 Object.keys () 返回该属性\n<ol>\n<li>当我们直接在一个对象上定义某个属性时，这个属性的 [[Enumerable]] 为 true</li>\n<li>当我们通过属性描述符定义一个属性时，这个属性的 [[Enumerable]] 默认为 false</li>\n</ol>\n</li>\n<li><code>value</code> : 属性的 value 值，读取属性时会返回该值，修改属性时，会对其进行修改\n<ol>\n<li>默认情况下这个值是 undefined</li>\n</ol>\n</li>\n<li><code>writable</code> : 表示是否可以修改属性的值\n<ol>\n<li>当我们直接在一个对象上定义某个属性时，这个属性的 [[Writable]] 为 true</li>\n<li>当我们通过属性描述符定义一个属性时，这个属性的 [[Writable]] 默认为 false</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p>存取 (访问器) 属性描述符</p>\n<ol>\n<li><code>configurable</code> : 属性是否可以通过 delete 删除属性，是否可以修改它的特性，或者是否可以将它修改为存取属性描述符\n<ol>\n<li>当我们直接在一个对象上定义某个属性时，这个属性的 [Configurable] 为 true</li>\n<li>当我们通过属性描述符定义一个属性时，这个属性的 [Configurable] 默认为 false</li>\n</ol>\n</li>\n<li><code>enumerable</code> : 属性是否可以通过 for-in 或者 Object.keys () 返回该属性\n<ol>\n<li>当我们直接在一个对象上定义某个属性时，这个属性的 [[Enumerable]] 为 true</li>\n<li>当我们通过属性描述符定义一个属性时，这个属性的 [[Enumerable]] 默认为 false</li>\n</ol>\n</li>\n<li><code>get</code> : 获取属性时会执行的函数，默认值为 <code>undefined</code></li>\n<li><code>set</code> : 设置属性时会执行的函数，默认值为 undefined</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> object = &#123;<br>  <span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">&quot;德尔蓝卡&quot;</span>,<br>  <span class=\"hljs-attr\">age</span>:<span class=\"hljs-number\">12</span>,<br>  <span class=\"hljs-attr\">_address</span>:<span class=\"hljs-string\">&quot;北京市&quot;</span><br>&#125;<br><span class=\"hljs-comment\">// 存取属性描述符</span><br><span class=\"hljs-comment\">// 1、隐藏某一个私有属性不希望直接被外界使用和赋值</span><br><span class=\"hljs-comment\">// 2、截获某一个属性它访问和设置值的过程时，会使用存储属性描述符</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">defineProperty</span>(object,<span class=\"hljs-string\">&quot;address&quot;</span>,&#123;<br>  <span class=\"hljs-attr\">configurable</span>:<span class=\"hljs-literal\">true</span>,<br>  <span class=\"hljs-attr\">enumerable</span>:<span class=\"hljs-literal\">true</span>,<br>  <span class=\"hljs-attr\">get</span>:<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-title function_\">foo</span>();<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_address</span>;<br>  &#125;,<br>  <span class=\"hljs-attr\">set</span>:<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">value</span>) &#123;<br>    <span class=\"hljs-title function_\">bar</span>();<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_address</span> = value<br>  &#125;<br>&#125;)<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(object.<span class=\"hljs-property\">address</span>);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(object);<br>object.<span class=\"hljs-property\">address</span> = <span class=\"hljs-string\">&quot;上海市&quot;</span>;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(object);<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;获取一次属性&quot;</span>);<br>&#125;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">bar</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;设置一次属性值&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>configurable</th>\n<th>enumerable</th>\n<th>value</th>\n<th>writable</th>\n<th>get</th>\n<th>set</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>数据属性描述符</td>\n<td>可以</td>\n<td>可以</td>\n<td>可以</td>\n<td>可以</td>\n<td>不可以</td>\n<td>不可以</td>\n</tr>\n<tr>\n<td>存取属性描述符</td>\n<td>可以</td>\n<td>可以</td>\n<td>不可以</td>\n<td>不可以</td>\n<td>可以</td>\n<td>可以</td>\n</tr>\n</tbody>\n</table>\n</li>\n</ol>\n</li>\n<li>\n<p>获取对象的属性描述符</p>\n<ol>\n<li><code>getOwnPropertyDescriptor</code> : 获取某一个特定属性的属性描述符</li>\n<li><code>getOwnPropertyDescriptors</code> : 获取所有属性的属性描述符</li>\n</ol>\n</li>\n<li>\n<p>访问器属性使用</p>\n</li>\n<li>\n<p>对象属性判断</p>\n</li>\n</ol>\n</li>\n<li>\n<p>对象的拷贝</p>\n<ol>\n<li>对象的引用赋值</li>\n<li>对象的浅拷贝</li>\n<li>对象的深拷贝</li>\n</ol>\n</li>\n<li>\n<p>ES6 对象增强</p>\n<ol>\n<li><code>Object.is()</code></li>\n<li>简写属性名</li>\n<li>可计算属性名称</li>\n<li>简写方法名</li>\n<li>对象解构\n<ol>\n<li>嵌套解构</li>\n<li>部分解构</li>\n<li>参数上下文匹配</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"2面向对象编程\"><a class=\"markdownIt-Anchor\" href=\"#2面向对象编程\">#</a> 2. 面向对象编程</h3>\n<ol>\n<li>\n<p>理解面向对象</p>\n<ol>\n<li>什么是面向对象编程</li>\n<li>面向对象编程的特性\n<ol>\n<li>封装</li>\n<li>继承</li>\n<li>多态</li>\n</ol>\n</li>\n<li>类和对象的关系</li>\n</ol>\n</li>\n<li>\n<p>创建对象方式</p>\n<ol>\n<li>工厂模式创建\n<ol>\n<li>该模式可以减少代码的重复量，缺点是无法获取对象的真实类型，获取对象类型都是 <code>object</code></li>\n</ol>\n</li>\n<li>构造函数创建\n<ol>\n<li>构造函数也称之为构造器 (constructor), 通常是我们在创建对象时会调用的函数</li>\n<li>一个普通的函数被使用 new 操作符来调用了，那么这个函数就称之为是一个构造函数</li>\n<li><code>new</code>\n<ol>\n<li>在函数内存中创建一个新的对象（空对象）</li>\n<li>这个对象内部的 [[prototype]] 属性会被赋值为该构造函数的 prototype 属性</li>\n<li>构造函数内部的 this，会指向创建出来的新对象</li>\n<li>执行函数的内部代码（函数体代码）</li>\n<li>如果构造函数没有返回非空对象，则返回创建出来的新对象</li>\n</ol>\n</li>\n<li>缺点：构造函数的缺点，需要为每一个对象的函数去创建一个函数对象实例，重复的创建对象</li>\n</ol>\n</li>\n<li>原型创建模式\n<ol>\n<li>认识原型</li>\n<li>对象的原型（隐式原型）\n<ol>\n<li>JavaScript 当中每个对象都有一个特殊的内置属性 [[prototype]]，这个特殊的对象可以指向另外一个对象</li>\n<li>原型对象的作用\n<ol>\n<li>当我们通过引用对象的属性 key 来获取一个 value 时，它会触发 [[Get]] 的操作</li>\n<li>这个操作会首先检查该属性是否有对应的属性，如果有的话就使用它</li>\n<li>如果对象中没有该属性，那么会访问对象 [[prototype]] 内置属性指向的对象上的属性</li>\n</ol>\n</li>\n<li>获取原型的方式\n<ol>\n<li>通过对象的__proto__属性可以获取到（但是这个是早期浏览器自己添加的，存在一定的兼容性问题）</li>\n<li>通过 Object.getPrototypeOf 方法可以获取到</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>函数的原型（显示原型）\n<ol>\n<li>所有的函数都有一个 prototype 的属性</li>\n<li></li>\n</ol>\n</li>\n<li><code>prototype属性</code>\n<ol>\n<li>指向对象的显式原型</li>\n</ol>\n</li>\n<li><code>constructor属性</code>\n<ol>\n<li>原型对象的属性：返回构造函数</li>\n</ol>\n</li>\n<li><code>__proto__属性</code>\n<ol>\n<li>指向对象的隐式原型</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p>面向对象继承</p>\n<ol>\n<li>\n<p>认识原型链</p>\n<ol>\n<li>深入原型对象\n<ol>\n<li><code>Object</code>  是顶层对象， <code>Object的原型对象上面没有原型对象而是null</code></li>\n<li><code>object</code>  是所有类的父类</li>\n</ol>\n</li>\n<li>简洁的原型语法</li>\n<li>修改原型的属性\n<ol>\n<li>需要在原型上添加过多的属性，通常我们会重新整个原型对象</li>\n<li>每创建一个函数，就会同时创建它的 prototype 对象，这个对象也会自动获取 constructor 属性</li>\n<li>这里给 prototype 重新赋值了一个对象，那么这个新对象的 constructor 属性，会指向 Object 构造函数，而不是 Person 构造函数了</li>\n<li>默认情况下原生的 constructor 属性是不可枚举</li>\n<li>如果希望解决这个问题，就可以使用我们前面介绍的 Object.defineProperty () 函数了</li>\n</ol>\n</li>\n<li>深入理解原型链\n<ol>\n<li>可以使用原型链继承</li>\n<li>原型链最顶层的原型对象就是 <code>Object</code>  的原型对象</li>\n</ol>\n</li>\n<li>原型和实例的关系\n<ol>\n<li>实例的属性 <code>__proto__</code> 指向原型对象</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p>继承的实现</p>\n<ol>\n<li>\n<p>原型链实现继承</p>\n<ol>\n<li>实现方式： <code>子类.prototype = new 父类();</code></li>\n<li>原型链实现继承的弊端\n<ol>\n<li>通过直接打印对象是看不到继承的属性</li>\n<li>这个属性会被多个对象共享，如果这个属性是一个引用类型，，其中一个共享对象进行修改时，那么就会造成问题，若是基本数据类型则不会出现该问题</li>\n<li>不能给 Person 传递参数，因为这个对象是一次性创建的</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p>借用构造函数实现继承 (经典继承)</p>\n<ol>\n<li>\n<p><code>constructor stealing</code> : 称之为借用构造函数、经典继承、伪造对象</p>\n</li>\n<li>\n<p>因为函数可以在任意的时刻被调用，因此通过 apply () 和 call () 方法也可以在新创建的对象上执行构造函数</p>\n</li>\n<li>\n<p>实现方式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 子类:私有属性和方法定义</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Student</span>(<span class=\"hljs-params\">name,age,friends,son</span>) &#123;<br>  <span class=\"hljs-comment\">// this指的是通过new绑定创建的stu对象</span><br>  <span class=\"hljs-title class_\">Person</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-variable language_\">this</span>,name,age,friends);<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">sno</span> = son;<br>&#125;<br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p>借用构造函数继承存在的弊端</p>\n<ol>\n<li>父类 Person 函数至少被调用了两次</li>\n<li>stu 原型对象上多出一些属性，而这些属性出现重复，因为子类本身就已经存在，但是这些属性没有存在的必要</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p>组合借用继承方式（<strong>和借用继承没有不同</strong>）</p>\n<ol>\n<li>实现方式</li>\n<li>存在弊端\n<ol>\n<li>一般都会调用两次父类构造函数，一次在创建子类原型的时候，一次在子类构造函数内部 (也就是每次创建子类实例的时候)</li>\n<li>所有的子类实例事实上会拥有两份父类的属性，一份在当前的实例自己里面 (也就是 person 本身的)，另一份在子类对应的原型对象中 (也就是 person.__proto__里面), 无需担心访问出现问题，默认一定是访问实例本身的属性</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p>寄生式继承函数</p>\n<ol>\n<li>实现方式</li>\n<li>存在弊端</li>\n</ol>\n</li>\n<li>\n<p>集成式组合继承</p>\n<ol>\n<li>释放方式</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p>ES6 类的使用</p>\n<ol>\n<li>class 类的定义\n<ol>\n<li>声明式、表达式两种</li>\n<li>构造方法</li>\n<li>属性定义</li>\n<li>方法定义</li>\n</ol>\n</li>\n<li>类的实例化过程\n<ol>\n<li>类的构建过程解析</li>\n<li>类的类型、function 类型</li>\n</ol>\n</li>\n<li>属性分类解析\n<ol>\n<li>实例属性和方法</li>\n<li>原型属性和访问器</li>\n<li>static 类方法和属性</li>\n</ol>\n</li>\n<li>class 类的继承\n<ol>\n<li>extends 关键字</li>\n<li>super 函数的使用\n<ol>\n<li>构造函数</li>\n<li>普通函数</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>Babel 的处理\n<ol>\n<li>Babel 工具对 class 的处理\n<ol>\n<li>阅读 Babel 转换后的代码</li>\n</ol>\n</li>\n<li>Babel 对继承的转换处理\n<ol>\n<li>Babel 继承的源码阅读</li>\n<li>_inherits</li>\n<li>_possibleConstructorReturn</li>\n<li>_classCallCheck</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p>面向对象面试题</p>\n</li>\n</ol>\n<h2 id=\"5es6~12新特性\"><a class=\"markdownIt-Anchor\" href=\"#5es6~12新特性\">#</a> 5.ES6~12 新特性</h2>\n<h3 id=\"1es6常见新特性\"><a class=\"markdownIt-Anchor\" href=\"#1es6常见新特性\">#</a> 1.ES6 常见新特性</h3>\n<ol>\n<li>基础补充\n<ol>\n<li>对象增强写法</li>\n<li>数组 / 对象解构</li>\n<li>var 与 let/const 区别</li>\n<li>作用域提升</li>\n<li>不允许重复声明变量</li>\n<li>window 对象的区别，let/const 不会添加到 window 对象上，<strong>保存的位置与之前也会有一定的区别</strong></li>\n<li></li>\n</ol>\n</li>\n</ol>\n<h3 id=\"2es7常见新特性\"><a class=\"markdownIt-Anchor\" href=\"#2es7常见新特性\">#</a> 2.ES7 常见新特性</h3>\n<h3 id=\"3es8常见新特性\"><a class=\"markdownIt-Anchor\" href=\"#3es8常见新特性\">#</a> 3.ES8 常见新特性</h3>\n<h3 id=\"4es9常见新特性\"><a class=\"markdownIt-Anchor\" href=\"#4es9常见新特性\">#</a> 4.ES9 常见新特性</h3>\n<h3 id=\"5es10常见新特性\"><a class=\"markdownIt-Anchor\" href=\"#5es10常见新特性\">#</a> 5.ES10 常见新特性</h3>\n<h3 id=\"6es11常见新特性\"><a class=\"markdownIt-Anchor\" href=\"#6es11常见新特性\">#</a> 6.ES11 常见新特性</h3>\n<h3 id=\"7es12常见新特性\"><a class=\"markdownIt-Anchor\" href=\"#7es12常见新特性\">#</a> 7.ES12 常见新特性</h3>\n<h2 id=\"6proxy-reflect\"><a class=\"markdownIt-Anchor\" href=\"#6proxy-reflect\">#</a> 6.Proxy-Reflect</h2>\n<h3 id=\"1proxy\"><a class=\"markdownIt-Anchor\" href=\"#1proxy\">#</a> 1.Proxy</h3>\n<ol>\n<li>在 ES6 中，新增了一个 Proxy 类，这个类从名字就可以看出来，是用于帮助我们创建一个代理</li>\n<li>如果我们希望监听一个对象的相关操作，那么我们可以先创建一个代理对象（Proxy 对象）</li>\n<li>之后对该对象的所有操作，都通过代理对象来完成，代理对象可以监听我们想要对原对象进行哪些操作</li>\n</ol>\n<h3 id=\"2reflect\"><a class=\"markdownIt-Anchor\" href=\"#2reflect\">#</a> 2.Reflect</h3>\n<ol>\n<li>Reflect 也是 ES6 新增的一个 API，它是一个对象，字面的意思是反射</li>\n<li>它主要提供了很多操作 JavaScript 对象的方法，有点像 Object 中操作对象的方法</li>\n<li></li>\n</ol>\n<h2 id=\"7异步处理\"><a class=\"markdownIt-Anchor\" href=\"#7异步处理\">#</a> 7. 异步处理</h2>\n<h3 id=\"1迭代器和生成器\"><a class=\"markdownIt-Anchor\" href=\"#1迭代器和生成器\">#</a> 1. 迭代器和生成器</h3>\n<ol>\n<li>\n<p>迭代器</p>\n<ol>\n<li>本身为一个对象，使用户在容器对象上遍访的对象，使用该接口无需关心对象的内部实现细节，<strong>迭代器是帮助我们对某个数据结构进行遍历的对象</strong></li>\n<li>在 JavaScript 中，<strong>迭代器也是一个具体的对象，这个对象需要符合迭代器协议 (iterator protocol)</strong>, 迭代器协议定义了产生一系列值 (无论是有限还是无限个) 的标准方式，那么在 js 中这个标准就是一个<strong>特定的 next 方法</strong></li>\n<li>next 方法有如下的要求\n<ol>\n<li>一个无参数函数或者含有一个参数的函数，返回一个应当拥有以下两个属性的对象\n<ol>\n<li>done（boolean）\n<ol>\n<li>如果迭代器可以产生序列中的下一个值，则为 false，这等价于没有指定 done 这个属性</li>\n<li>如果迭代器已将序列迭代完毕，则为 true。这种情况下，value 是可选的，如果它依然存在，即为迭代结束之后的默认返回值</li>\n</ol>\n</li>\n<li>value\n<ol>\n<li>迭代器返回的任何 JavaScript 值，done 为 true 时可省略</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p>可迭代对象</p>\n<ol>\n<li>\n<p>当一个对象实现了 ** <code>iterable protocol</code> ** 协议时，它就是一个可迭代对象</p>\n</li>\n<li>\n<p>这个对象要求是必须实现 <code>@@iterator方法</code> ，即 ** <code>[Symbol.iterator]属性对应着一个函数</code>  ** 在代码中我们使用 <code>Symbol.iterator</code>  访问该属性</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//可迭代对象iteratorObj</span><br><span class=\"hljs-keyword\">const</span> iteratorObj = &#123;<br>  <span class=\"hljs-attr\">array</span>: [<span class=\"hljs-number\">111</span>, <span class=\"hljs-number\">222</span>, <span class=\"hljs-number\">333</span>],<br>  [<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>]: <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> index = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">return</span> &#123;<br>      <span class=\"hljs-comment\">// 返回一个迭代器</span><br>      <span class=\"hljs-attr\">next</span>:<span class=\"hljs-function\">() =&gt;</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> (index &lt; <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">array</span>.<span class=\"hljs-property\">length</span>) &#123;<br>          <span class=\"hljs-keyword\">return</span> &#123; <span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">false</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">array</span>[index++] &#125;<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>          <span class=\"hljs-keyword\">return</span> &#123; <span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-literal\">undefined</span> &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(iteratorObj[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>]);<br><span class=\"hljs-comment\">// 调用该方法会生成一个可迭代对象</span><br><span class=\"hljs-keyword\">const</span> iterator = iteratorObj[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>]();<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(iterator);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(iterator.<span class=\"hljs-title function_\">next</span>());<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(iterator.<span class=\"hljs-title function_\">next</span>());<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(iterator.<span class=\"hljs-title function_\">next</span>());<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(iterator.<span class=\"hljs-title function_\">next</span>());<br><span class=\"hljs-comment\">// 返回一个新的可迭代对象</span><br><span class=\"hljs-keyword\">const</span> iterator2 = iteratorObj[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>]();<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(iterator2);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(iterator2.<span class=\"hljs-title function_\">next</span>());<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(iterator2.<span class=\"hljs-title function_\">next</span>());<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(iterator2.<span class=\"hljs-title function_\">next</span>());<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(iterator2.<span class=\"hljs-title function_\">next</span>());<br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p>原生迭代器对象，已经实现可迭代协议有： <code>String、Array、Map、Set、arguments对象、NodeList集合</code></p>\n</li>\n<li>\n<p>可迭代对象的应用</p>\n<ol>\n<li>JavaScript 语法： <code>for...of</code> 、 <code>展开语法(spread syntax)</code> 、 <code>yield*</code> 、 <code>解构赋值</code></li>\n<li>创建一些对象时： <code>new Map</code> 、 <code>new WeakMap</code> 、 <code>new Set</code> 、 <code>new WeakSet</code></li>\n<li>一些方法调用： <code>Promise.all(iterator)</code> 、 <code>Promise.race(iterator)</code> 、 <code>Array.from(iterator)</code></li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p>生成器</p>\n<ol>\n<li>生成器是 ES6 中新增的一种函数控制、使用的方案，它可以让我们更加灵活的控制函数什么时候继续执行、暂停执行等</li>\n<li>生成器函数也是一个函数，但是和普通的函数有一些区别\n<ol>\n<li>生成器函数需要<strong>在 function 的后面加一个符号 <code>*</code> </strong></li>\n<li>生成器函数可以通过 ** <code>yield关键字</code>  ** 来控制函数的执行流程</li>\n<li>生成器函数的<strong>返回值是一个 Generator</strong>（生成器）</li>\n<li>生成器事实上是一种<strong>特殊的迭代器</strong>，MDN：Instead,they return a special type of iterator,called aGenerator</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"2promise的使用\"><a class=\"markdownIt-Anchor\" href=\"#2promise的使用\">#</a> 2.Promise 的使用</h3>\n<ol>\n<li>\n<p><code>Promise</code>  是一个类，可以翻译为承诺、许诺、期约</p>\n</li>\n<li>\n<p><code>then</code>  是一个 Promise 对象上的一个方法：实际上是 Promise 原型上的 <code>Promise.prototype.then()</code></p>\n</li>\n<li>\n<p>浏览器的循环事件</p>\n<ol>\n<li>\n<p>进程与线程理解</p>\n<ol>\n<li>进程：计算已经运行的程序，是操作系统管理程序的一种方式，启动一个应用程序，就会默认启动一个进程 (也可能是多个进程)</li>\n<li>线程：操作系统能够运行运算调度的最小单位，通常情况下它被包含在进程中，启动每一个进程中，都会启动至少一个线程用来执行程序中的代码，这个线程被称为主线程</li>\n</ol>\n</li>\n<li>\n<p>浏览器中的 JavaScript 线程</p>\n<ol>\n<li>JavaScript 是单线程，拥有自己的容器进程：浏览器或 node</li>\n<li>浏览器是多进程的，当我们打开一个 tab 页面时就会开启一个新的进程，这是为了防止一个页面卡死而造成所有页面无法响应，整个浏览器需要强制退出</li>\n<li>JavaScript 同一时刻只能做一件事情，如果该事情非常耗时，那么当前的线程就会被阻塞，然而浏览器每一个进程是多线程的，那么其他的线程可以来完成这个耗时的操作，如：网络请求、定时器等，我们只需要在特定的时刻执行回调即可</li>\n</ol>\n</li>\n<li>\n<p>事件循环图解</p>\n<p><img src=\"../../all_photo/image-20220725112224437.png\" alt=\"image-20220725112224437\"></p>\n</li>\n<li>\n<p>微任务和宏任务</p>\n<ol>\n<li>微任务队列 (microtask queue)：一般有 queueMicrotask ()、Promise 的 then 回调、MutationObserver 的 API: 监听 DOM 的调用</li>\n<li>宏任务队列 (macrotask queue)：一般有定时器、ajax、DOM 事件点击、UI Rendering 渲染</li>\n<li>规范：在执行任何的宏任务之前，都需要先保证微任务队列已经被清空</li>\n</ol>\n</li>\n<li>\n<p>事件循环对于两个队列的优先级</p>\n<ol>\n<li><code>main script</code>  代码优先执行</li>\n<li>在执行任何一个宏任务之前 (不是队列，而是一个宏任务)，都会先查看微任务队列中是否有任务需要执行，也就是说宏任务执行之前，必须保证微任务对队列是空的，若果不为空，那么就优先执行微任务队列中的任务 (回调函数)</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p>node 的事件循环</p>\n<ol>\n<li>浏览器中 <code>EventLoop即事件循环</code> 是根据 HTML5 定义的规范来实现的，不同的浏览器可能会有不同的实现，而 node 中是由 <code>libuv库</code> 现实的</li>\n<li>微任务和宏任务\n<ol>\n<li>宏任务 (macrotask)：setTimeout、setInterval、IO 事件、setImmediate、close 事件</li>\n<li>微任务 (microtask)：Promise 的 then 回调、process.nextTick、queueMicrotask</li>\n<li>node 队列执行顺序\n<ol>\n<li><code>next tick microtask queue</code></li>\n<li><code>other microtask queue</code></li>\n<li><code>timer queue</code></li>\n<li><code>poll queue</code></li>\n<li><code>check queue</code></li>\n<li><code>close queue</code></li>\n</ol>\n</li>\n<li></li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"3async和await\"><a class=\"markdownIt-Anchor\" href=\"#3async和await\">#</a> 3.async 和 await</h3>\n<ol>\n<li><code>async</code>  关键字用于声明一个异步函数</li>\n<li><code>async</code>  是 <code>asynchronous</code>  单词的缩写，意思为异步、非同步</li>\n<li><code>sync</code>  是 <code>synchronous</code>  单词的缩写，意思为同步、同时</li>\n</ol>\n<h2 id=\"8模块化与包管理工具\"><a class=\"markdownIt-Anchor\" href=\"#8模块化与包管理工具\">#</a> 8. 模块化与包管理工具</h2>\n<ol>\n<li>模块化开发\n<ol>\n<li>认识模块化开发\n<ol>\n<li>事实上模块化开发最终的目的是将程序划分成一个个小的结构，这个结构中编写属于自己的逻辑代码，有自己的作用域，不会影响到其他的结构，这个结构可以将自己希望暴露的变量、函数、对象等导出给其结构使用，也可以通过某种方式，导入另外结构中的变量、函数、对象</li>\n</ol>\n</li>\n<li><code>commonJS规范</code>\n<ol>\n<li><code>CommonJS和Node关系</code>\n<ol>\n<li>CommonJS 是一个规范，最初是在浏览器以外的地方使用，当时被命名为<strong> ServerJS</strong>，后来为了体现它的广泛性，修改为<strong> CommonJS</strong>，平时我们也会简称为<strong> CJS</strong></li>\n<li>Node 是 CommonJS 在服务器端一个具有代表性的实现，Browserify 是 CommonJS 在浏览器中的一种实现，webpack 打包工具具备对 CommonJS 的支持和转换，Node 中对 CommonJS 进行了支持和实现，让我们在开发 node 的过程中可以方便的进行模块化开发，在 Node 中每一个 js 文件都是一个单独的模块，这个模块中包括 CommonJS 规范的核心变量：exports、module.exports、require，我们可以使用这些变量来方便的进行模块化开发，前面我们提到过模块化的核心是导出和导入，Node 中对其进行了实现：exports 和 module.exports 可以负责对模块中的内容进行导出，require 函数可以帮助我们导入其他模块（自定义模块、系统模块、第三方库模块）中的内容</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><code>AMD和CMD规范</code></li>\n<li><code>ESModule规范化</code></li>\n<li><code>ES Module和CommonJS</code></li>\n</ol>\n</li>\n<li>npm 包管理工具</li>\n</ol>\n",
            "tags": [
                "JavaScript"
            ]
        }
    ]
}